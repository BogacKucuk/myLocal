// 1. Test for NonTurkishDocumentStrategy
package com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.util;

import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.constants.GoldDocumentType;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.BranchInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.CustomerInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.request.CreateSinglePdfRequestDto;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import java.util.Arrays;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

class NonTurkishDocumentStrategyTest {

    private NonTurkishDocumentStrategy strategy;
    private DocumentContext context;
    private CreateSinglePdfRequestDto requestDto;

    @BeforeEach
    void setUp() {
        strategy = new NonTurkishDocumentStrategy();
    }

    @Test
    @DisplayName("Should return correct document type")
    void shouldReturnCorrectDocumentType() {
        assertEquals(GoldDocumentType.ALTIN_SOZLESMESI_TR_EN_IMZA_BARKODLU, 
                    strategy.getDocumentType());
    }

    @Test
    @DisplayName("Should be applicable when nationality is not TUR")
    void shouldBeApplicableWhenNationalityIsNotTurkish() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("USA")
                .customerNumber(12345L)
                .customerFullName("John Doe")
                .customerAddress("123 Main St")
                .accountType("G")
                .tckn("98765432100")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchName("ISTANBUL")
                .branchAddress("Levent, Istanbul")
                .countryCode("TR")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.509)
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertTrue(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should not be applicable when nationality is TUR")
    void shouldNotBeApplicableWhenNationalityIsTurkish() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(12345L)
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertFalse(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should generate valid XML with correct structure")
    void shouldGenerateValidXmlWithCorrectStructure() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("USA")
                .customerNumber(12345L)
                .customerFullName("John Doe")
                .customerAddress("123 Main St, New York")
                .accountType("G")
                .tckn("98765432100")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchName("ISTANBUL")
                .branchAddress("Levent Business District")
                .branchCity("Istanbul")
                .countryCode("TR")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.509)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        assertTrue(xml.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
        assertTrue(xml.contains("<ALTIN_SOZLESMESI_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("</ALTIN_SOZLESMESI_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("<musteri_adresi>123 Main St, New York</musteri_adresi>"));
        assertTrue(xml.contains("<musteri_numarasi>12345</musteri_numarasi>"));
        assertTrue(xml.contains("<musteri_adi_soyadi>John Doe</musteri_adi_soyadi>"));
        assertTrue(xml.contains("<dokumanin_dili>USA</dokumanin_dili>"));
        assertTrue(xml.contains("<hesap_tipi>G</hesap_tipi>"));
        assertTrue(xml.contains("<banka_adresi>Levent Business District</banka_adresi>"));
        assertTrue(xml.contains("<kulce_altin_yatirma_ucret_orani>0.509</kulce_altin_yatirma_ucret_orani>"));
    }

    @Test
    @DisplayName("Should escape XML special characters")
    void shouldEscapeXmlSpecialCharacters() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("GER")
                .customerNumber(99999L)
                .customerFullName("Hans & Greta <Mueller>")
                .customerAddress("Straße \"123\" & 'Garden'")
                .accountType("G")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchAddress("Test & Branch")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.5)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertTrue(xml.contains("Hans &amp; Greta &lt;Mueller&gt;"));
        assertTrue(xml.contains("Straße &quot;123&quot; &amp; &apos;Garden&apos;"));
        assertTrue(xml.contains("Test &amp; Branch"));
    }

    @Test
    @DisplayName("Should handle null values gracefully")
    void shouldHandleNullValuesGracefully() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("USA")
                .customerNumber(12345L)
                .customerFullName(null)
                .customerAddress(null)
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchAddress(null)
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.5)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        assertTrue(xml.contains("<musteri_adi_soyadi></musteri_adi_soyadi>"));
        assertTrue(xml.contains("<musteri_adresi></musteri_adresi>"));
        assertTrue(xml.contains("<banka_adresi></banka_adresi>"));
    }
}

// 2. Test for KktcBranchDocumentStrategy
package com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.util;

import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.constants.GoldDocumentType;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.BranchInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.CustomerInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.request.CreateSinglePdfRequestDto;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

class KktcBranchDocumentStrategyTest {

    private KktcBranchDocumentStrategy strategy;
    private DocumentContext context;
    private CreateSinglePdfRequestDto requestDto;

    @BeforeEach
    void setUp() {
        strategy = new KktcBranchDocumentStrategy();
    }

    @Test
    @DisplayName("Should return correct document type for KKTC")
    void shouldReturnCorrectDocumentType() {
        assertEquals(GoldDocumentType.ALTIN_ORTAK_SOZLESME_KKTC_TR_EN_IMZA_BARKODLU, 
                    strategy.getDocumentType());
    }

    @Test
    @DisplayName("Should be applicable when country code is KKTC")
    void shouldBeApplicableWhenCountryCodeIsKKTC() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(22223333L)
                .build();

        BranchInfo branch = BranchInfo.builder()
                .countryCode("KKTC")
                .branchName("LEFKOŞA")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertTrue(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should not be applicable when country code is not KKTC")
    void shouldNotBeApplicableWhenCountryCodeIsNotKKTC() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .countryCode("TR")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertFalse(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should generate XML with KKTC specific fields")
    void shouldGenerateXmlWithKKTCSpecificFields() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(33334444L)
                .customerFullName("Mehmet Yılmaz")
                .customerAddress("Girne Caddesi No:45, Lefkoşa")
                .accountType("G")
                .tckn("11122233344")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchName("LEFKOŞA")
                .branchAddress("Lefkoşa Merkez, KKTC")
                .branchCity("Lefkoşa")
                .countryCode("KKTC")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.300)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        assertTrue(xml.contains("<ALTIN_ORTAK_SOZLESME_KKTC_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("</ALTIN_ORTAK_SOZLESME_KKTC_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("<sahit_imza_flag>E</sahit_imza_flag>"));
        assertTrue(xml.contains("<kktckn_tckn_ykn_vkn>11122233344</kktckn_tckn_ykn_vkn>"));
        assertTrue(xml.contains("<sube_sehri>Lefkoşa</sube_sehri>"));
        assertTrue(xml.contains("<sube_adi>LEFKOŞA</sube_adi>"));
        assertTrue(xml.contains("<musteri_adresi>Girne Caddesi No:45, Lefkoşa</musteri_adresi>"));
        assertTrue(xml.contains("<musteri_numarasi>33334444</musteri_numarasi>"));
        assertTrue(xml.contains("<musteri_adi_soyadi>Mehmet Yılmaz</musteri_adi_soyadi>"));
    }

    @Test
    @DisplayName("Should handle null branch city gracefully")
    void shouldHandleNullBranchCityGracefully() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(12345L)
                .tckn("12345678900")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .countryCode("KKTC")
                .branchCity(null)
                .branchName("TEST")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.3)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        assertTrue(xml.contains("<sube_sehri></sube_sehri>"));
    }
}

// 3. Test for JointAccountDocumentStrategy
package com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.util;

import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.constants.GoldDocumentType;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.BranchInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.CustomerInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.request.CreateSinglePdfRequestDto;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import java.util.Arrays;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

class JointAccountDocumentStrategyTest {

    private JointAccountDocumentStrategy strategy;
    private DocumentContext context;
    private CreateSinglePdfRequestDto requestDto;

    @BeforeEach
    void setUp() {
        strategy = new JointAccountDocumentStrategy();
    }

    @Test
    @DisplayName("Should return correct document type for joint account")
    void shouldReturnCorrectDocumentType() {
        assertEquals(GoldDocumentType.ALTIN_ORTAK_SOZLESME_TR_EN_IMZA_BARKODLU, 
                    strategy.getDocumentType());
    }

    @Test
    @DisplayName("Should be applicable when account type is ORTAK")
    void shouldBeApplicableWhenAccountTypeIsOrtak() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .accountType("ORTAK")
                .customerNumber(12345L)
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertTrue(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should not be applicable when account type is not ORTAK")
    void shouldNotBeApplicableWhenAccountTypeIsNotOrtak() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .accountType("G")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertFalse(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should generate XML with single customer info")
    void shouldGenerateXmlWithSingleCustomerInfo() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(55556666L)
                .customerFullName("Ali Veli")
                .customerAddress("Ankara Caddesi No:10")
                .accountType("ORTAK")
                .tckn("55566677788")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchAddress("Ankara Merkez")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.509)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        assertTrue(xml.contains("<ALTIN_ORTAK_SOZLESME_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("<musteri_adres>Ankara Caddesi No:10</musteri_adres>"));
        assertTrue(xml.contains("<musteri_kimlik_no>55566677788</musteri_kimlik_no>"));
        assertTrue(xml.contains("<ortak_hesap_numarasi>3338692</ortak_hesap_numarasi>"));
        assertTrue(xml.contains("<ortaklik_yapisi>Ayni</ortaklik_yapisi>"));
        assertTrue(xml.contains("<barkod>1</barkod>"));
        assertTrue(xml.contains("<musteri_numarasi>55556666</musteri_numarasi>"));
        assertTrue(xml.contains("<musteri_adi_soyadi>Ali Veli</musteri_adi_soyadi>"));
    }

    @Test
    @DisplayName("Should generate XML with multiple customers for joint account")
    void shouldGenerateXmlWithMultipleCustomers() {
        // Arrange
        CustomerInfo customer1 = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(11111111L)
                .customerFullName("Ayşe Kaya")
                .customerAddress("İstanbul Cad. No:1")
                .accountType("ORTAK")
                .tckn("11111111111")
                .build();

        CustomerInfo customer2 = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(22222222L)
                .customerFullName("Ahmet Kaya")
                .customerAddress("İstanbul Cad. No:2")
                .accountType("ORTAK")
                .tckn("22222222222")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchAddress("İstanbul Merkez")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Arrays.asList(customer1, customer2))
                .branchInfo(branch)
                .commissionRate(0.509)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        // Check for first customer
        assertTrue(xml.contains("<musteri_kimlik_no>11111111111</musteri_kimlik_no>"));
        assertTrue(xml.contains("<musteri_numarasi>11111111</musteri_numarasi>"));
        assertTrue(xml.contains("<musteri_adi_soyadi>Ayşe Kaya</musteri_adi_soyadi>"));
        // Check for second customer
        assertTrue(xml.contains("<musteri_kimlik_no>22222222222</musteri_kimlik_no>"));
        assertTrue(xml.contains("<musteri_numarasi>22222222</musteri_numarasi>"));
        assertTrue(xml.contains("<musteri_adi_soyadi>Ahmet Kaya</musteri_adi_soyadi>"));
    }

    @Test
    @DisplayName("Should handle empty customer list gracefully")
    void shouldHandleEmptyCustomerListGracefully() {
        // Arrange
        BranchInfo branch = BranchInfo.builder()
                .branchAddress("Test Branch")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.emptyList())
                .branchInfo(branch)
                .commissionRate(0.5)
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertThrows(IndexOutOfBoundsException.class, () -> strategy.isApplicable(context));
    }
}

// 4. Test for DefaultGoldDocumentStrategy
package com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.util;

import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.constants.GoldDocumentType;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.BranchInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.CustomerInfo;
import com.garantibbva.depositwithdrawlmngt.moneywithdrawbusiness.service.contract.model.request.CreateSinglePdfRequestDto;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

class DefaultGoldDocumentStrategyTest {

    private DefaultGoldDocumentStrategy strategy;
    private DocumentContext context;
    private CreateSinglePdfRequestDto requestDto;

    @BeforeEach
    void setUp() {
        strategy = new DefaultGoldDocumentStrategy();
    }

    @Test
    @DisplayName("Should return correct document type for default strategy")
    void shouldReturnCorrectDocumentType() {
        assertEquals(GoldDocumentType.ALTIN_SOZLESMESI_TR_EN_IMZA_BARKODLU, 
                    strategy.getDocumentType());
    }

    @Test
    @DisplayName("Should always be applicable as default fallback")
    void shouldAlwaysBeApplicable() {
        // Arrange - any context
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .accountType("G")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .countryCode("TR")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertTrue(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should generate XML with default fields")
    void shouldGenerateXmlWithDefaultFields() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(44445555L)
                .customerFullName("Ali Veli")
                .customerAddress("Beşiktaş, Istanbul")
                .accountType("G")
                .tckn("99988877766")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchName("BEŞİKTAŞ")
                .branchAddress("Beşiktaş Merkez, Istanbul")
                .countryCode("TR")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.509)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertNotNull(xml);
        assertTrue(xml.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
        assertTrue(xml.contains("<ALTIN_SOZLESMESI_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("</ALTIN_SOZLESMESI_TR_EN_IMZA_BARKODLU>"));
        assertTrue(xml.contains("<tckn_ykn_vkn>99988877766</tckn_ykn_vkn>"));
        assertTrue(xml.contains("<sube_adi>BEŞİKTAŞ</sube_adi>"));
        assertTrue(xml.contains("<musteri_adresi>Beşiktaş Merkez, Istanbul</musteri_adresi>"));
        assertTrue(xml.contains("<musteri_numarasi>44445555</musteri_numarasi>"));
        assertTrue(xml.contains("<musteri_adi_soyadi>Ali Veli</musteri_adi_soyadi>"));
        assertTrue(xml.contains("<dokumanin_dili>TUR</dokumanin_dili>"));
        assertTrue(xml.contains("<hesap_tipi>G</hesap_tipi>"));
        assertTrue(xml.contains("<banka_adresi>Beşiktaş Merkez, Istanbul</banka_adresi>"));
    }

    @Test
    @DisplayName("Should be applicable with null values")
    void shouldBeApplicableWithNullValues() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality(null)
                .accountType(null)
                .build();

        BranchInfo branch = BranchInfo.builder()
                .countryCode(null)
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .build();

        context = new DocumentContext(requestDto);

        // Act & Assert
        assertTrue(strategy.isApplicable(context));
    }

    @Test
    @DisplayName("Should handle special characters in XML")
    void shouldHandleSpecialCharactersInXml() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(12345L)
                .customerFullName("Test & <User>")
                .customerAddress("Address with \"quotes\" & 'apostrophes'")
                .tckn("12345678900")
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchName("Branch & Co.")
                .branchAddress("Test < Address >")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.5)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertTrue(xml.contains("Test &amp; &lt;User&gt;"));
        assertTrue(xml.contains("Address with &quot;quotes&quot; &amp; &apos;apostrophes&apos;"));
        assertTrue(xml.contains("Branch &amp; Co."));
        assertTrue(xml.contains("Test &lt; Address &gt;"));
    }

    @Test
    @DisplayName("Should include version information in XML")
    void shouldIncludeVersionInformationInXml() {
        // Arrange
        CustomerInfo customer = CustomerInfo.builder()
                .nationality("TUR")
                .customerNumber(12345L)
                .build();

        BranchInfo branch = BranchInfo.builder()
                .branchAddress("Test")
                .build();

        requestDto = CreateSinglePdfRequestDto.builder()
                .customerInfo(Collections.singletonList(customer))
                .branchInfo(branch)
                .commissionRate(0.5)
                .build();

        context = new DocumentContext(requestDto);

        // Act
        String xml = strategy.generateXmlData(context);

        // Assert
        assertTrue(xml.contains("<versiyon_numarasi>1</versiyon_numarasi>"));
        assertTrue(xml.contains("<versiyon_tarihi>31/01/2017</versiyon_tarihi>"));
        assertTrue(xml.contains("<tarih>")); // Contains current date
    }
}
