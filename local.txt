package com.garantibbva.depositwithdrawalmngmt.moneywithdrawbusiness.data.impl.dao;

import com.garanti.ark.data.jdbc.ArkEntityBeanPropertyRowMapper;
import com.garanti.ark.data.jdbc.JdbcAccessor;
import com.garantibbva.depositwithdrawalmngmt.moneywithdrawbusiness.data.constant.TransactionQueryConstant;
import com.garantibbva.depositwithdrawalmngmt.moneywithdrawbusiness.data.contract.model.entity.TransactionEntity;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.RowMapper;

import java.math.BigDecimal;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TransactionDaoImplTest {

    @Mock
    private JdbcAccessor jdbcAccessor;

    @InjectMocks
    private TransactionDaoImpl transactionDao;

    private TransactionEntity transactionEntity;
    private List<TransactionEntity> transactionEntities;

    @BeforeEach
    void setUp() {
        // TransactionEntity setup
        transactionEntity = new TransactionEntity();
        transactionEntity.setOperationType("DEPOSIT");
        transactionEntity.setCustomerNumber(123456);
        transactionEntity.setCustomerAccount("ACC123456");
        transactionEntity.setTransactionAmount(new BigDecimal("1000.00"));
        transactionEntity.setCurrency("TRY");
        transactionEntity.setOpCode("OP001");
        transactionEntity.setStoredRequest("REQUEST_001");
        transactionEntity.setChannel("MOBILE");

        transactionEntities = new ArrayList<>();
        transactionEntities.add(transactionEntity);
        
        // Reflection to inject jdbcAccessor
        try {
            java.lang.reflect.Field field = transactionDao.getClass().getSuperclass().getDeclaredField("jdbcAccessor");
            field.setAccessible(true);
            field.set(transactionDao, jdbcAccessor);
        } catch (Exception e) {
            fail("Failed to inject jdbcAccessor: " + e.getMessage());
        }
    }

    @Test
    void testFindByCustomerNumber_Success() throws SQLException {
        // Given
        Integer customerNumber = 123456;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenReturn(transactionEntities);

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertEquals(1, result.get().size());
        assertEquals(transactionEntity, result.get().get(0));
        
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        );
    }

    @Test
    void testFindByCustomerNumber_EmptyResult() throws SQLException {
        // Given
        Integer customerNumber = 999999;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenReturn(Collections.emptyList());

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertTrue(result.get().isEmpty());
        
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        );
    }

    @Test
    void testFindByCustomerNumber_NullResult() throws SQLException {
        // Given
        Integer customerNumber = 888888;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenReturn(null);

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertFalse(result.isPresent());
        
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        );
    }

    @Test
    void testFindByCustomerNumber_MultipleResults() throws SQLException {
        // Given
        Integer customerNumber = 777777;
        
        TransactionEntity secondTransaction = new TransactionEntity();
        secondTransaction.setOperationType("WITHDRAWAL");
        secondTransaction.setCustomerNumber(customerNumber);
        secondTransaction.setCustomerAccount("ACC777777");
        secondTransaction.setTransactionAmount(new BigDecimal("500.00"));
        secondTransaction.setCurrency("USD");
        secondTransaction.setOpCode("OP002");
        secondTransaction.setStoredRequest("REQUEST_002");
        secondTransaction.setChannel("WEB");
        
        List<TransactionEntity> multipleEntities = new ArrayList<>();
        multipleEntities.add(transactionEntity);
        multipleEntities.add(secondTransaction);
        
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenReturn(multipleEntities);

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertEquals(2, result.get().size());
        assertEquals(transactionEntity, result.get().get(0));
        assertEquals(secondTransaction, result.get().get(1));
    }

    @Test
    void testFindByCustomerNumber_DataAccessException() throws SQLException {
        // Given
        Integer customerNumber = 666666;
        DataAccessException dataAccessException = new DataAccessException("Connection error") {};
        
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenThrow(dataAccessException);

        // When & Then
        assertThrows(SQLException.class, () -> {
            transactionDao.findByCustomerNumber(customerNumber);
        });
        
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        );
    }

    @Test
    void testFindByCustomerNumber_RuntimeException() throws SQLException {
        // Given
        Integer customerNumber = 555555;
        RuntimeException runtimeException = new RuntimeException("Unexpected error");
        
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenThrow(runtimeException);

        // When & Then
        assertThrows(SQLException.class, () -> {
            transactionDao.findByCustomerNumber(customerNumber);
        });
    }

    @Test
    void testFindByCustomerNumber_NullCustomerNumber() throws SQLException {
        // Given
        Integer customerNumber = null;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                isNull()
        )).thenReturn(Collections.emptyList());

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertTrue(result.get().isEmpty());
        
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                isNull()
        );
    }

    @Test
    void testFindByCustomerNumber_ZeroCustomerNumber() throws SQLException {
        // Given
        Integer customerNumber = 0;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(0)
        )).thenReturn(transactionEntities);

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertEquals(1, result.get().size());
    }

    @Test
    void testFindByCustomerNumber_NegativeCustomerNumber() throws SQLException {
        // Given
        Integer customerNumber = -12345;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(-12345)
        )).thenReturn(Collections.emptyList());

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertTrue(result.get().isEmpty());
    }

    @Test
    void testFindByCustomerNumber_VerifyRowMapperType() throws SQLException {
        // Given
        Integer customerNumber = 444444;
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenReturn(transactionEntities);

        // When
        transactionDao.findByCustomerNumber(customerNumber);

        // Then
        ArgumentCaptor<RowMapper> rowMapperCaptor = ArgumentCaptor.forClass(RowMapper.class);
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                rowMapperCaptor.capture(),
                eq(customerNumber)
        );
        
        assertTrue(rowMapperCaptor.getValue() instanceof ArkEntityBeanPropertyRowMapper);
    }

    @Test
    void testFindByCustomerNumber_LargeDataSet() throws SQLException {
        // Given
        Integer customerNumber = 111111;
        List<TransactionEntity> largeEntityList = new ArrayList<>();
        
        for (int i = 0; i < 1000; i++) {
            TransactionEntity entity = new TransactionEntity();
            entity.setOperationType("TYPE_" + i);
            entity.setCustomerNumber(customerNumber);
            entity.setCustomerAccount("ACC_" + i);
            entity.setTransactionAmount(new BigDecimal(i * 100));
            entity.setCurrency("TRY");
            entity.setOpCode("OP_" + i);
            entity.setStoredRequest("REQ_" + i);
            entity.setChannel("CHANNEL_" + i);
            largeEntityList.add(entity);
        }
        
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenReturn(largeEntityList);

        // When
        Optional<List<TransactionEntity>> result = transactionDao.findByCustomerNumber(customerNumber);

        // Then
        assertTrue(result.isPresent());
        assertEquals(1000, result.get().size());
        assertEquals("TYPE_0", result.get().get(0).getOperationType());
        assertEquals("TYPE_999", result.get().get(999).getOperationType());
    }

    @Test
    void testFindByCustomerNumber_SQLException() throws SQLException {
        // Given
        Integer customerNumber = 333333;
        // Spring JDBC unchecked exception kullanır
        DataAccessException dataAccessException = new DataAccessException("Database connection failed") {};
        
        when(jdbcAccessor.query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        )).thenThrow(dataAccessException);

        // When & Then
        SQLException thrown = assertThrows(SQLException.class, () -> {
            transactionDao.findByCustomerNumber(customerNumber);
        });
        
        // DAO SQLException'a wrap ediyor
        assertNotNull(thrown);
        
        verify(jdbcAccessor).query(
                eq(TransactionQueryConstant.FIND_BY_CUSTOMER_NUMBER),
                any(ArkEntityBeanPropertyRowMapper.class),
                eq(customerNumber)
        );
    }
}
