package com.garantibbva.depositwithdrawalmngt.moneywithdrawbusiness.service.impl;

import com.garanti.branchinstructionmanagement.business.proto.v0.BranchInstruction.ReadBranchInstructionDepositWithdrawal;
import com.garanti.branchinstructionmanagement.business.proto.v0.BranchInstruction.ReadBranchInstructionDepositWithdrawalRequest;
import com.garanti.branchinstructionmanagement.business.proto.v0.BranchInstruction.ReadBranchInstructionDepositWithdrawalResponse;
import com.garanti.branchinstructionmanagement.business.proto.v0.BranchInstructionGrpcServiceGrpc.BranchInstructionGrpcServiceBlockingStub;
import com.garantibbva.ark.custom.proto.BigDecimalProto;
import com.garantibbva.depositwithdrawalmngt.moneywithdrawbusiness.service.contract.model.request.DigitalOrderReadRequestDto;
import com.garantibbva.depositwithdrawalmngt.moneywithdrawbusiness.service.contract.model.response.DigitalOrderReadResponseDto;
import com.garantibbva.depositwithdrawalmngt.moneywithdrawbusiness.service.contract.model.response.ReadBranchInstructionDepositWithdrawalDto;
import com.google.protobuf.ByteString;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class DigitalOrderServiceImplTest {

    @Mock
    private BranchInstructionGrpcServiceBlockingStub blockingStub;

    @InjectMocks
    private DigitalOrderServiceImpl digitalOrderService;

    private DigitalOrderReadRequestDto requestDto;
    private ReadBranchInstructionDepositWithdrawalResponse grpcResponse;

    @BeforeEach
    void setUp() {
        requestDto = DigitalOrderReadRequestDto.builder()
                .instructionId(12345L)
                .customerNum(100001)
                .accountNumber(200001)
                .branchCode(500)
                .amount(new BigDecimal("1000.00"))
                .currencyCode("TRY")
                .identityNumber("12345678901")
                .documentId("DOC123")
                .transactionDate("2025-09-29")
                .status("ACTIVE")
                .transactionType(1)
                .processUnitNum(10)
                .build();

        // Dış servisin BigDecimal proto tipini kullanıyoruz
        BigDecimalProto.BigDecimal protoAmount = createExternalProtoBigDecimal(new BigDecimal("1000.00"));

        ReadBranchInstructionDepositWithdrawal grpcInstruction = 
                ReadBranchInstructionDepositWithdrawal.newBuilder()
                .setInstructionId(12345L)
                .setCustomerNum(100001)
                .setAccountNumber(200001)
                .setBranchCode(500)
                .setAmount(protoAmount)
                .setCurrencyCode("TRY")
                .setIdentityNumber("12345678901")
                .setDocumentId("DOC123")
                .setTransactionDate("2025-09-29")
                .setStatus("ACTIVE")
                .setTransactionType(1)
                .setProcessUnitNum(10)
                .build();

        grpcResponse = ReadBranchInstructionDepositWithdrawalResponse.newBuilder()
                .addReadBranchInstructionDepositWithdrawal(grpcInstruction)
                .build();
    }

    // Dış servisin BigDecimal proto tipini oluştur (com.garantibbva.ark.custom.proto)
    private BigDecimalProto.BigDecimal createExternalProtoBigDecimal(BigDecimal value) {
        if (value == null) {
            return BigDecimalProto.BigDecimal.getDefaultInstance();
        }
        return BigDecimalProto.BigDecimal.newBuilder()
                .setScale(value.scale())
                .setPrecision(value.precision())
                .setValue(ByteString.copyFrom(value.unscaledValue().toByteArray()))
                .build();
    }

    @Test
    void readDigitalOrder_whenValidRequest_shouldReturnMappedResponse() {
        // Given
        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(grpcResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestDto);

        // Then
        assertNotNull(result);
        assertNotNull(result.getReadBranchInstructionDepositWithdrawal());
        assertEquals(1, result.getReadBranchInstructionDepositWithdrawal().size());

        ReadBranchInstructionDepositWithdrawalDto resultDto = 
                result.getReadBranchInstructionDepositWithdrawal().get(0);

        assertEquals(12345L, resultDto.getInstructionId());
        assertEquals(100001, resultDto.getCustomerNum());
        assertEquals(200001, resultDto.getAccountNumber());
        assertEquals(500, resultDto.getBranchCode());
        assertEquals("TRY", resultDto.getCurrencyCode());
        assertEquals("12345678901", resultDto.getIdentityNumber());
        assertEquals("DOC123", resultDto.getDocumentId());
        assertEquals("2025-09-29", resultDto.getTransactionDate());
        assertEquals("ACTIVE", resultDto.getStatus());
        assertEquals(1, resultDto.getTransactionType());
        assertEquals(10, resultDto.getProcessUnitNum());
        assertNotNull(resultDto.getAmount());

        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcReturnsEmptyList_shouldReturnEmptyResponse() {
        // Given
        ReadBranchInstructionDepositWithdrawalResponse emptyResponse = 
                ReadBranchInstructionDepositWithdrawalResponse.newBuilder().build();

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(emptyResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestDto);

        // Then
        assertNotNull(result);
        assertNotNull(result.getReadBranchInstructionDepositWithdrawal());
        assertTrue(result.getReadBranchInstructionDepositWithdrawal().isEmpty());

        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcReturnsMultipleInstructions_shouldReturnAllInstructions() {
        // Given
        BigDecimalProto.BigDecimal amount1 = createExternalProtoBigDecimal(new BigDecimal("1000.00"));
        BigDecimalProto.BigDecimal amount2 = createExternalProtoBigDecimal(new BigDecimal("2000.00"));

        ReadBranchInstructionDepositWithdrawal instruction1 = 
                ReadBranchInstructionDepositWithdrawal.newBuilder()
                .setInstructionId(12345L)
                .setCustomerNum(100001)
                .setAmount(amount1)
                .setCurrencyCode("TRY")
                .build();

        ReadBranchInstructionDepositWithdrawal instruction2 = 
                ReadBranchInstructionDepositWithdrawal.newBuilder()
                .setInstructionId(67890L)
                .setCustomerNum(100002)
                .setAmount(amount2)
                .setCurrencyCode("USD")
                .build();

        ReadBranchInstructionDepositWithdrawalResponse multipleResponse = 
                ReadBranchInstructionDepositWithdrawalResponse.newBuilder()
                .addReadBranchInstructionDepositWithdrawal(instruction1)
                .addReadBranchInstructionDepositWithdrawal(instruction2)
                .build();

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(multipleResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestDto);

        // Then
        assertNotNull(result);
        assertEquals(2, result.getReadBranchInstructionDepositWithdrawal().size());

        ReadBranchInstructionDepositWithdrawalDto firstDto = result.getReadBranchInstructionDepositWithdrawal().get(0);
        assertEquals(12345L, firstDto.getInstructionId());
        assertEquals(100001, firstDto.getCustomerNum());
        assertEquals("TRY", firstDto.getCurrencyCode());

        ReadBranchInstructionDepositWithdrawalDto secondDto = result.getReadBranchInstructionDepositWithdrawal().get(1);
        assertEquals(67890L, secondDto.getInstructionId());
        assertEquals(100002, secondDto.getCustomerNum());
        assertEquals("USD", secondDto.getCurrencyCode());

        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcThrowsNotFoundException_shouldPropagateException() {
        // Given
        StatusRuntimeException exception = new StatusRuntimeException(
                Status.NOT_FOUND.withDescription("Instruction not found"));

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenThrow(exception);

        // When & Then
        StatusRuntimeException thrown = assertThrows(StatusRuntimeException.class, () ->
            digitalOrderService.readDigitalOrder(requestDto)
        );

        assertEquals(Status.NOT_FOUND.getCode(), thrown.getStatus().getCode());
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcThrowsUnavailableException_shouldPropagateException() {
        // Given
        StatusRuntimeException exception = new StatusRuntimeException(
                Status.UNAVAILABLE.withDescription("Branch instruction service unavailable"));

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenThrow(exception);

        // When & Then
        StatusRuntimeException thrown = assertThrows(StatusRuntimeException.class, () ->
            digitalOrderService.readDigitalOrder(requestDto)
        );

        assertEquals(Status.UNAVAILABLE.getCode(), thrown.getStatus().getCode());
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcThrowsInternalException_shouldPropagateException() {
        // Given
        StatusRuntimeException exception = new StatusRuntimeException(
                Status.INTERNAL.withDescription("Internal server error"));

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenThrow(exception);

        // When & Then
        StatusRuntimeException thrown = assertThrows(StatusRuntimeException.class, () ->
            digitalOrderService.readDigitalOrder(requestDto)
        );

        assertEquals(Status.INTERNAL.getCode(), thrown.getStatus().getCode());
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcThrowsDeadlineExceededException_shouldPropagateException() {
        // Given
        StatusRuntimeException exception = new StatusRuntimeException(
                Status.DEADLINE_EXCEEDED.withDescription("Request timeout"));

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenThrow(exception);

        // When & Then
        StatusRuntimeException thrown = assertThrows(StatusRuntimeException.class, () ->
            digitalOrderService.readDigitalOrder(requestDto)
        );

        assertEquals(Status.DEADLINE_EXCEEDED.getCode(), thrown.getStatus().getCode());
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcThrowsPermissionDeniedException_shouldPropagateException() {
        // Given
        StatusRuntimeException exception = new StatusRuntimeException(
                Status.PERMISSION_DENIED.withDescription("Access denied"));

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenThrow(exception);

        // When & Then
        StatusRuntimeException thrown = assertThrows(StatusRuntimeException.class, () ->
            digitalOrderService.readDigitalOrder(requestDto)
        );

        assertEquals(Status.PERMISSION_DENIED.getCode(), thrown.getStatus().getCode());
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenRequestWithNullFields_shouldStillProcess() {
        // Given
        DigitalOrderReadRequestDto requestWithNulls = DigitalOrderReadRequestDto.builder()
                .instructionId(null)
                .customerNum(null)
                .amount(null)
                .currencyCode(null)
                .build();

        ReadBranchInstructionDepositWithdrawalResponse emptyResponse = 
                ReadBranchInstructionDepositWithdrawalResponse.newBuilder().build();

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(emptyResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestWithNulls);

        // Then
        assertNotNull(result);
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenResponseWithAllFields_shouldMapAllFieldsCorrectly() {
        // Given
        BigDecimalProto.BigDecimal fullAmount = createExternalProtoBigDecimal(new BigDecimal("5000.75"));

        ReadBranchInstructionDepositWithdrawal fullInstruction = 
                ReadBranchInstructionDepositWithdrawal.newBuilder()
                .setInstructionId(99999L)
                .setCustomerNum(888888)
                .setAccountNumber(777777)
                .setBranchCode(666)
                .setAmount(fullAmount)
                .setCurrencyCode("EUR")
                .setIdentityNumber("98765432109")
                .setDocumentId("DOC999")
                .setTransactionDate("2025-12-31")
                .setStatus("COMPLETED")
                .setTransactionType(2)
                .setProcessUnitNum(20)
                .build();

        ReadBranchInstructionDepositWithdrawalResponse fullResponse = 
                ReadBranchInstructionDepositWithdrawalResponse.newBuilder()
                .addReadBranchInstructionDepositWithdrawal(fullInstruction)
                .build();

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(fullResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestDto);

        // Then
        assertNotNull(result);
        assertEquals(1, result.getReadBranchInstructionDepositWithdrawal().size());

        ReadBranchInstructionDepositWithdrawalDto dto = result.getReadBranchInstructionDepositWithdrawal().get(0);
        assertEquals(99999L, dto.getInstructionId());
        assertEquals(888888, dto.getCustomerNum());
        assertEquals(777777, dto.getAccountNumber());
        assertEquals(666, dto.getBranchCode());
        assertEquals("EUR", dto.getCurrencyCode());
        assertEquals("98765432109", dto.getIdentityNumber());
        assertEquals("DOC999", dto.getDocumentId());
        assertEquals("2025-12-31", dto.getTransactionDate());
        assertEquals("COMPLETED", dto.getStatus());
        assertEquals(2, dto.getTransactionType());
        assertEquals(20, dto.getProcessUnitNum());
        assertNotNull(dto.getAmount());

        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenGrpcResponseIsNull_shouldHandleGracefully() {
        // Given
        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(null);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestDto);

        // Then
        assertNull(result);
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenRequestWithZeroValues_shouldProcessCorrectly() {
        // Given
        DigitalOrderReadRequestDto zeroRequest = DigitalOrderReadRequestDto.builder()
                .instructionId(0L)
                .customerNum(0)
                .accountNumber(0)
                .branchCode(0)
                .amount(BigDecimal.ZERO)
                .currencyCode("")
                .transactionType(0)
                .processUnitNum(0)
                .build();

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(grpcResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(zeroRequest);

        // Then
        assertNotNull(result);
        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }

    @Test
    void readDigitalOrder_whenAmountHasMultipleDecimalPlaces_shouldPreservePrecision() {
        // Given
        BigDecimal preciseAmount = new BigDecimal("1234.56789");
        BigDecimalProto.BigDecimal protoPreciseAmount = createExternalProtoBigDecimal(preciseAmount);

        ReadBranchInstructionDepositWithdrawal preciseInstruction = 
                ReadBranchInstructionDepositWithdrawal.newBuilder()
                .setInstructionId(12345L)
                .setAmount(protoPreciseAmount)
                .build();

        ReadBranchInstructionDepositWithdrawalResponse preciseResponse = 
                ReadBranchInstructionDepositWithdrawalResponse.newBuilder()
                .addReadBranchInstructionDepositWithdrawal(preciseInstruction)
                .build();

        when(blockingStub.readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class)))
                .thenReturn(preciseResponse);

        // When
        DigitalOrderReadResponseDto result = digitalOrderService.readDigitalOrder(requestDto);

        // Then
        assertNotNull(result);
        assertEquals(1, result.getReadBranchInstructionDepositWithdrawal().size());
        
        ReadBranchInstructionDepositWithdrawalDto dto = result.getReadBranchInstructionDepositWithdrawal().get(0);
        assertNotNull(dto.getAmount());
        assertEquals(5, dto.getAmount().scale());

        verify(blockingStub, times(1)).readBranchInstructionDepositWithdrawal(any(ReadBranchInstructionDepositWithdrawalRequest.class));
    }
}
