package com.ykb.corebanking.commission;

import com.dynatrace.oneagent.sdk.OneAgentSDKFactory;
import com.dynatrace.oneagent.sdk.api.CustomServiceTracer;
import com.dynatrace.oneagent.sdk.api.OneAgentSDK;
import com.dynatrace.oneagent.sdk.api.enums.SDKState;
import com.ykb.corebanking.commission.batch.base.Tuple;
import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.infrastructure.configuration.NumeratorInitializer;
import lombok.Generated;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.ArrayUtils;
import org.slf4j.MDC;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.retry.annotation.EnableRetry;
import org.springframework.scheduling.annotation.EnableScheduling;

import java.util.Locale;
import java.util.Map;
import java.util.Properties;

import static com.ykb.corebanking.commission.batch.common.constants.BatchConstants.JOB_NAME;

@Slf4j
@EnableCaching
@EnableScheduling
@EnableRetry
@EnableAutoConfiguration(exclude = {SecurityAutoConfiguration.class, ManagementWebSecurityAutoConfiguration.class})
@SpringBootApplication(scanBasePackages = {"com.ykb"})
@Generated
public class DefinitionMain {

    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("System Environment:" + System.lineSeparator());
        for (Map.Entry<String, String> envVar : System.getenv().entrySet()) {
            sb.append(envVar.getKey() + ": " + envVar.getValue() + System.lineSeparator());
        }
        log.info(sb.toString());

        Locale.setDefault(Locale.forLanguageTag("tr-TR"));

        ConfigurableApplicationContext applicationContext = new SpringApplicationBuilder(DefinitionMain.class)
                .initializers(new NumeratorInitializer())
                .run(args);

        int responseCode = 0;
        if (args.length > 0) {
            try {
                final String jobName = args[0];
                OneAgentSDK oneAgentSdk = OneAgentSDKFactory.createInstance();
                SDKState currentState = oneAgentSdk.getCurrentState();
                log.info("Dynatrace is current state: {}", currentState.name());

                CustomServiceTracer tracer = oneAgentSdk.traceCustomService("DefinitionBatch : ", jobName);
                tracer.start();

                final String[] jobKeysAndValues = (String[]) ArrayUtils.remove(args, 0);
                final Properties props = new Properties();
                CustomJobParameters<String, Object> customJobParameters = applicationContext.getBean(CustomJobParameters.class);
                customJobParameters.addParameter(JOB_NAME, jobName);
                for (String parameter : jobKeysAndValues) {
                    log.info("Prm to extract: {}", parameter);
                    Tuple<String, String> keyValue = Tuple.build(parameter.split("="));
                    log.info("Provided job parameter to be passed, Key:Value => {} : {}", keyValue.getFirst(),
                            keyValue.getSecond());
                    props.setProperty(keyValue.getFirst(), keyValue.getSecond());
                    customJobParameters.addParameter(keyValue.getFirst(), keyValue.getSecond());
                }
                JobLauncher jobLauncher = applicationContext.getBean(JobLauncher.class);
                JobExecution jobExecution = jobLauncher.run(applicationContext.getBean(jobName, Job.class), new JobParameters());
                if (!ExitStatus.COMPLETED.equals(jobExecution.getExitStatus())) {
                    responseCode = 1;
                }

                tracer.end();
            } catch (Exception e) {
                log.error("Job failed with exception", e);
                responseCode = 1;
            } finally {
                log.info("Job execution completed. Clearing MDC context");
                MDC.clear();
                if (applicationContext != null) {
                    applicationContext.close();
                    log.info("********* closed the context");
                }
                System.exit(responseCode);
            }
        }
    }

}

package com.ykb.corebanking.commission.batch.base;

import lombok.Getter;
import org.springframework.util.Assert;


@Getter
public class Tuple<T, K> {
    private final T first;
    private final K second;

    private Tuple(T first, K second) {
        this.first = first;
        this.second = second;
    }

    public static Tuple<String, String> build(String[] items) {
        Assert.notNull(items, "'items' can not be null");
        Assert.isTrue(items.length == 2, "'items' must have 2 items in in");
        return new Tuple<>(items[0], items[1]);
    }

}

package com.ykb.corebanking.commission.batch.common.constants;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class BatchConstants {
    public static final String JOB_NAME = "JOB_NAME";
}

package com.ykb.corebanking.commission.batch.common.stats;

import lombok.Getter;
import org.springframework.batch.core.JobExecution;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;


@Getter
public class JobStatistics {

    static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");

    private String jobName;
    private String id;
    private String version;
    private List<JobStatsParameter> parameters;
    private String status;
    private String startTime;
    private String endTime;
    private String exitStatus;
    private String failureExceptions;
    private List<StepStatistics> steps;

    public JobStatistics(JobExecution jobExecution) {
        this.jobName = jobExecution.getJobInstance().getJobName();
        this.id = jobExecution.getJobInstance().getId().toString();
        this.version = jobExecution.getJobInstance().getVersion().toString();
        this.status = jobExecution.getStatus().toString();
        this.startTime = Optional.ofNullable(jobExecution.getStartTime()).orElse(LocalDateTime.MIN).format(DATE_TIME_FORMATTER);
        this.endTime = Optional.ofNullable(jobExecution.getEndTime()).orElse(LocalDateTime.MIN).format(DATE_TIME_FORMATTER);
        this.exitStatus = jobExecution.getExitStatus().toString();
        this.failureExceptions = printStackTrace(jobExecution.getFailureExceptions());
        this.parameters = new ArrayList<>();
        jobExecution.getJobParameters().getParameters().forEach((k, v) -> parameters.add(new JobStatsParameter(k,
                v.getValue().toString())));
        this.steps = new ArrayList<>();
        jobExecution.getStepExecutions().forEach(se -> steps.add(new StepStatistics(se)));
    }


    static String printStackTrace(List<Throwable> exceptions) {
        try (ByteArrayOutputStream os = new ByteArrayOutputStream();
             PrintWriter pw = new PrintWriter(os)) {
            exceptions.forEach(e -> e.printStackTrace(pw));
            return new String(os.toByteArray());
        } catch (IOException e) {
            return "";
        }
    }
}

package com.ykb.corebanking.commission.batch.common.stats;

import lombok.AllArgsConstructor;
import lombok.Getter;


@Getter
@AllArgsConstructor
public class JobStatsParameter {
	private String key;
	private String value;
}

package com.ykb.corebanking.commission.batch.common.stats;

import lombok.Getter;
import org.springframework.batch.core.StepExecution;

import java.time.LocalDateTime;
import java.util.Optional;

import static com.ykb.corebanking.commission.batch.common.stats.JobStatistics.printStackTrace;


@Getter
public class StepStatistics {
    private String name;
    private String id;
    private String version;
    private String readCount;
    private String writeCount;
    private String commitCount;
    private String rollbackCount;
    private String readSkipCount;
    private String processSkipCount;
    private String writeSkipCount;
    private String startTime;
    private String endTime;
    private String exitStatus;
    private String failureExceptions;

    StepStatistics(StepExecution execution) {
        this.name = execution.getStepName();
        this.id = execution.getId().toString();
        this.version = execution.getVersion().toString();
        this.readCount = String.valueOf(execution.getReadCount());
        this.writeCount = String.valueOf(execution.getWriteCount());
        this.commitCount = String.valueOf(execution.getCommitCount());
        this.rollbackCount = String.valueOf(execution.getRollbackCount());
        this.readSkipCount = String.valueOf(execution.getReadSkipCount());
        this.processSkipCount = String.valueOf(execution.getProcessSkipCount());
        this.writeSkipCount = String.valueOf(execution.getWriteSkipCount());
        this.startTime = Optional.ofNullable(execution.getStartTime()).orElse(LocalDateTime.MIN).format(JobStatistics.DATE_TIME_FORMATTER);
        this.endTime = Optional.ofNullable(execution.getEndTime()).orElse(LocalDateTime.MIN).format(JobStatistics.DATE_TIME_FORMATTER);
        this.exitStatus = execution.getExitStatus().toString();
        this.failureExceptions = printStackTrace(execution.getFailureExceptions());
    }
}		


package com.ykb.corebanking.commission.batch.common;

import lombok.Setter;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.lang.Nullable;

import java.util.Collections;
import java.util.Map;

public class ExecuteSqlScriptTasklet implements Tasklet {


    protected final String sql;
    protected final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    @Setter
    protected SqlParamProvider sqlParamProvider;

    public ExecuteSqlScriptTasklet(String sql, NamedParameterJdbcTemplate namedParameterJdbcTemplate) {
        this(sql, namedParameterJdbcTemplate, Collections::emptyMap);
    }

    public ExecuteSqlScriptTasklet(String sql, NamedParameterJdbcTemplate namedParameterJdbcTemplate,
                                   @Nullable SqlParamProvider sqlParamProvider) {
        this.sql = sql;
        this.namedParameterJdbcTemplate = namedParameterJdbcTemplate;
        this.sqlParamProvider = sqlParamProvider;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

        namedParameterJdbcTemplate.update(sql, sqlParamProvider.provide());

        return RepeatStatus.FINISHED;
    }


    @FunctionalInterface
    public interface SqlParamProvider {
        Map<String, Object> provide();
    }

}

package com.ykb.corebanking.commission.batch.common;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.annotation.OnProcessError;
import org.springframework.batch.core.annotation.OnReadError;
import org.springframework.batch.core.annotation.OnWriteError;
import org.springframework.batch.core.listener.ItemListenerSupport;
import org.springframework.batch.item.Chunk;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Lazy
public class ItemFailureLoggerListener<I, R> extends ItemListenerSupport<I, R> {

    @Override
    @OnReadError
    public void onReadError(Exception ex) {
        log.error("Encountered an error on reader", ex);
    }

    @Override
    @OnProcessError
    public void onProcessError(I item, Exception ex) {
        log.error("Encountered an error on processor", ex);
        log.error("Failed item: {}", item);
    }

    @Override
    @OnWriteError
    public void onWriteError(Exception ex, Chunk<? extends R> item) {
        log.error("Encountered an error on writer", ex);
        if(item != null){
            item.forEach(i -> log.error("Possible failed item: {}", i));
        }
    }
}

package com.ykb.corebanking.commission.batch.common;

import org.slf4j.MDC;
import org.springframework.core.task.TaskDecorator;

import java.util.Map;


public class MdcTaskDecorator implements TaskDecorator {
    @Override
    public Runnable decorate(Runnable runnable) {
        final Map<String, String> contextMap = MDC.getCopyOfContextMap();
        return () -> {
            try {
                if (contextMap != null) {
                    MDC.setContextMap(contextMap);
                }
                runnable.run();
            } finally {
                MDC.clear();
            }
        };
    }
}

package com.ykb.corebanking.commission.batch.common;

import freemarker.cache.ClassTemplateLoader;
import freemarker.cache.FileTemplateLoader;
import freemarker.cache.TemplateLoader;
import freemarker.core.Environment;
import freemarker.template.Configuration;
import freemarker.template.DefaultObjectWrapper;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.Writer;


public class TemplateWriter {


    private final Template template;
    private final Writer writer;

    public TemplateWriter(Resource templateResource, Writer writer) throws IOException {
        this(templateResource,writer,"utf-8");
    }

    public TemplateWriter(Resource templateResource, Writer writer, String defaultEncoding) throws IOException {
        this.writer = writer;

        final Configuration configuration = new Configuration(Configuration.VERSION_2_3_27);
        configuration.setTemplateLoader(getTemplateLoader(templateResource));
        configuration.setObjectWrapper(new DefaultObjectWrapper(Configuration.VERSION_2_3_27));
        configuration.setDefaultEncoding(defaultEncoding);
        this.template = configuration.getTemplate(templateResource.getFilename());
    }


    public void process(Object data) {
        final Environment environment;
        try {
            environment = template.createProcessingEnvironment(data, writer);
            environment.process();
        } catch (TemplateException | IOException e) {
            ExceptionUtils.rethrow(e);
        }

    }

    private TemplateLoader getTemplateLoader(Resource resource) throws IOException {
        if (resource instanceof ClassPathResource classPathResource) {
            return new ClassTemplateLoader(classPathResource.getClassLoader(), "/templates");
        } else if (resource instanceof FileSystemResource) {
            return new FileTemplateLoader(resource.getFile());
        } else {
            throw new IllegalArgumentException("Resource can be FileSystemResource or ClassPathResource");
        }
    }
}

package com.ykb.corebanking.commission.batch.configuration;

import com.ykb.corebanking.commission.batch.common.ItemFailureLoggerListener;
import com.ykb.corebanking.commission.batch.common.MdcTaskDecorator;
import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.domain.util.ControlUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.core.step.builder.TaskletStepBuilder;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.support.TaskExecutorRepeatTemplate;
import org.springframework.boot.ApplicationArguments;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Lazy;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.transaction.PlatformTransactionManager;

import static com.ykb.corebanking.commission.batch.common.constants.BatchConstants.JOB_NAME;

@Slf4j
public abstract class BaseJobConfiguration {
    protected BaseJobConfiguration(JobRepository jobRepository,
                                   CommonJobExecutionListener commonJobExecutionListener, JobConfigurationParameter jobConfigurationParameter,
                                   CustomJobParameters<String, Object> customJobParameters, ItemFailureLoggerListener<? extends Object, ? extends Object> itemFailureLoggerListener,
                                   ApplicationArguments applicationArguments) {
        this.jobRepository = jobRepository;
        this.commonJobExecutionListener = commonJobExecutionListener;
        this.customJobParameters = customJobParameters;
        this.config = jobConfigurationParameter.getJobs().get(
                applicationArguments.getSourceArgs().length > 0 ? applicationArguments.getSourceArgs()[0] : customJobParameters.getByKey(JOB_NAME)
        );
        this.itemFailureLoggerListener = itemFailureLoggerListener;
    }

    private final JobRepository jobRepository;
    private final CommonJobExecutionListener commonJobExecutionListener;
    protected final CustomJobParameters<String, Object> customJobParameters;
    protected JobConfigurationParameter.JobParameter config;
    protected final ItemFailureLoggerListener<? extends Object, ? extends Object> itemFailureLoggerListener;

    @Bean
    @Lazy
    public ThreadPoolTaskExecutor commonBatchTaskExecutor() {
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setTaskDecorator(new MdcTaskDecorator());
        if(config != null){
            threadPoolTaskExecutor.setMaxPoolSize(ControlUtil.nvl(config.getThreadPoolExecutor().getMaxPoolSize(),1));
            threadPoolTaskExecutor.setCorePoolSize(ControlUtil.nvl(config.getThreadPoolExecutor().getCorePoolSize(),1));
        }
        return threadPoolTaskExecutor;
    }

    protected JobBuilder getCommonJobBuilder(String jobName) {
        return new JobBuilder(jobName,jobRepository)
                .listener(commonJobExecutionListener);
    }


    protected StepBuilder getCommonStepBuilder(String stepName) {
        return new StepBuilder(stepName, jobRepository)
                .listener(new CommonStepExecutionListener());
    }

    protected TaskletStepBuilder generateTaskletStep(String stepName, Tasklet tasklet, PlatformTransactionManager transactionManager) {
        return getCommonStepBuilder(stepName)
                .tasklet(tasklet, transactionManager);
    }

    public TaskExecutorRepeatTemplate repeatTemplate(ThreadPoolTaskExecutor threadPoolTaskExecutor, int throttleLimit){
        TaskExecutorRepeatTemplate repeatTemplate = new TaskExecutorRepeatTemplate();
        repeatTemplate.setTaskExecutor(threadPoolTaskExecutor);
        repeatTemplate.setThrottleLimit(throttleLimit); // NOSONAR
        return repeatTemplate;
    }
}

package com.ykb.corebanking.commission.batch.configuration;

import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing(dataSourceRef = "jobRepoDatasource")
public class BatchConfiguration {

    @Bean
    public DataSource jobRepoDatasource(){
        return new EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.H2)
                .setName("job-metadata-db")
                .addScript("classpath:org/springframework/batch/core/schema-drop-h2.sql")
                .addScript("classpath:org/springframework/batch/core/schema-h2.sql")
                .build();
    }

}

package com.ykb.corebanking.commission.batch.configuration;

import com.ykb.corebanking.commission.batch.common.TemplateWriter;
import com.ykb.corebanking.commission.batch.common.stats.JobStatistics;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.context.annotation.Lazy;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;


@Slf4j
@Component
@Lazy
public class CommonJobExecutionListener implements JobExecutionListener {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        log.info("Job {} is started at {}", jobExecution.getJobInstance().getJobName(), jobExecution.getStartTime());
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        JobStatistics stats = new JobStatistics(jobExecution);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        try (PrintWriter pw = new PrintWriter(bos)) {
            ClassPathResource templateResource = new ClassPathResource("templates/JobStats.ftl");
            TemplateWriter tw = new TemplateWriter(templateResource, pw);
            tw.process(Map.of("stats", stats));
            log.info(new String(bos.toByteArray()));

        } catch (IOException e) {
            log.info("Stats: {}", stats);
        }
        log.info("Job {} is finished at {} with status={}",
                jobExecution.getJobInstance().getJobName(), jobExecution.getEndTime(), jobExecution.getStatus());
    }
}

package com.ykb.corebanking.commission.batch.configuration;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;

import java.util.Date;


@Slf4j
public class CommonStepExecutionListener implements StepExecutionListener {

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        log.info("Step {} completed at {} with status: {}", stepExecution.getStepName(), new Date(System.currentTimeMillis()), stepExecution.getStatus());
        return stepExecution.getExitStatus();
    }

    @Override
    public void beforeStep(StepExecution stepExecution) {
        log.info("Step {} is started at {}", stepExecution.getStepName(), stepExecution.getStartTime());
    }
}

package com.ykb.corebanking.commission.batch.configuration;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.jdbc.lock.DefaultLockRepository;
import org.springframework.integration.jdbc.lock.JdbcLockRegistry;
import org.springframework.integration.jdbc.lock.LockRepository;

import javax.sql.DataSource;

@Configuration
public class JdbcLockConfig {

    @Value("${lock.ttl}")
    private Integer ttl;

    @Bean
    public DefaultLockRepository defaultLockRepository(DataSource dataSource){
        DefaultLockRepository defaultLockRepository = new DefaultLockRepository(dataSource);
        defaultLockRepository.setPrefix("SPRING_");
        defaultLockRepository.setTimeToLive(ttl);
        defaultLockRepository.setCheckDatabaseOnStart(false);
        return defaultLockRepository;
    }

    @Bean
    public JdbcLockRegistry jdbcLockRegistry(LockRepository lockRepository){
        return new JdbcLockRegistry(lockRepository);
    }
}

package com.ykb.corebanking.commission.batch.configuration;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Component("jobConfigurationParameter")
@ConfigurationProperties(prefix = "batch-configuration")
@Getter
@Setter
@Lazy
public class JobConfigurationParameter {

    private  Map<String, JobParameter> jobs = new HashMap<>();

    @Getter
    @Setter
    public static class JobParameter {

        private ThreadPoolParameter threadPoolExecutor = new ThreadPoolParameter();
        private Map<String, StepParameter> steps = new HashMap<>();

        @Getter
        @Setter
        public static class StepParameter {

            private Integer chunkSize;
            private Integer throttleLimit;
            private Integer pageSize;
            private Integer fetchSize;
        }

        @Getter
        @Setter
        public static class ThreadPoolParameter {

            private Integer corePoolSize;
            private Integer maxPoolSize;
        }
    }
}

package com.ykb.corebanking.commission.batch.utils;

import com.ykb.corebanking.commission.domain.constants.CommonConstants;
import com.ykb.corebanking.commission.domain.constants.CustomerTariffDefinitionConstants;
import com.ykb.corebanking.commission.domain.data.bulkcustomertariffdefinition.BulkCustomerTariffDefinitionDetailDTO;
import com.ykb.corebanking.commission.domain.enums.CustomerTariffDefinitionTypes;
import com.ykb.corebanking.commission.domain.util.ControlUtil;
import lombok.experimental.UtilityClass;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.Date;

@UtilityClass
public class BulkCustomerTariffDefinitionUtil {

    public String getType(BulkCustomerTariffDefinitionDetailDTO bulkCustomerTariffDefinitionDetailDTO) {
        if (!ControlUtil.isEmpty(bulkCustomerTariffDefinitionDetailDTO.getBasePriceDefinition())
                && CommonConstants.YES.equals(bulkCustomerTariffDefinitionDetailDTO.getBasePriceDefinition())) {
            return CustomerTariffDefinitionTypes.BASE_PRICE.getKey();
        } else if (CustomerTariffDefinitionConstants.FIRM_GROUP_EXEMPTION_CODE.equals(bulkCustomerTariffDefinitionDetailDTO.getOperationCode())) {
            return CustomerTariffDefinitionTypes.GROUP_FIRM.getKey();
        } else if (bulkCustomerTariffDefinitionDetailDTO.getTariffAmountRate() != null) {
            return CustomerTariffDefinitionTypes.TARIFF_RATIO.getKey();
        } else if (bulkCustomerTariffDefinitionDetailDTO.getTransactionAmountRate() != null) {
            return CustomerTariffDefinitionTypes.OPERATION_AMT_RATIO.getKey();
        } else if (bulkCustomerTariffDefinitionDetailDTO.getAmount() != null && BigDecimal.ZERO.compareTo(bulkCustomerTariffDefinitionDetailDTO.getAmount()) < 0) {
            return CustomerTariffDefinitionTypes.AMOUNT.getKey();
        } else if (bulkCustomerTariffDefinitionDetailDTO.getAmount() == null || BigDecimal.ZERO.compareTo(bulkCustomerTariffDefinitionDetailDTO.getAmount()) == 0) {
            return CustomerTariffDefinitionTypes.NO_COMMISSION.getKey();
        }
        return null;
    }

    public StringBuilder getExportFileNameFromDataModel(String fileName, Long id) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("ddMMyyHHmmss");
        String date = dateFormat.format(new Date());
        int lastIndexOfExtension = fileName.lastIndexOf(".");
        StringBuilder fileNameReturn = new StringBuilder(fileName.substring(0, lastIndexOfExtension));
        fileNameReturn.append("_Sonuc_");
        fileNameReturn.append(id);
        fileNameReturn.append("_");
        fileNameReturn.append(date);
        fileNameReturn.append(".csv");
        return fileNameReturn;
    }

    public String clearTurkishChars(String str) {
        String ret = str;
        char[] turkishChars = new char[] {0x131, 0x130, 0xFC, 0xDC, 0xF6, 0xD6, 0x15F, 0x15E, 0xE7, 0xC7, 0x11F, 0x11E};
        char[] englishChars = new char[] {'i', 'I', 'u', 'U', 'o', 'O', 's', 'S', 'c', 'C', 'g', 'G'};
        for (int i = 0; i < turkishChars.length; i++) {
            ret = ret.replaceAll(new String(new char[]{turkishChars[i]}), new String(new char[]{englishChars[i]}));
        }
        return ret;
    }
}

package com.ykb.corebanking.commission.batch.utils;

import com.ykb.corebanking.commission.domain.constants.CommonConstants;
import com.ykb.corebanking.commission.domain.data.basepricedefinition.BasePriceDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrLimitDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrMinLimitDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrRuleDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDetailDTO;
import com.ykb.corebanking.commission.domain.data.customerdeserve.CustomerDeserveOutputDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefinitionDTO;
import com.ykb.corebanking.commission.domain.enums.CtrExemptionType;
import com.ykb.corebanking.commission.domain.enums.CtrLimitControlStatus;
import com.ykb.corebanking.commission.domain.enums.CustomerTariffDefinitionTypes;
import com.ykb.corebanking.commission.domain.util.CommonUtil;
import com.ykb.corebanking.commission.domain.util.ControlUtil;
import com.ykb.corebanking.commission.domain.util.CustomerTariffDefinitionUtil;
import lombok.experimental.UtilityClass;
import org.apache.commons.lang3.StringUtils;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static com.ykb.corebanking.commission.domain.constants.CommonConstants.CURRENCY_CODE_TL;
import static com.ykb.corebanking.commission.domain.enums.CustomerDeserveType.DESERVE;
import static com.ykb.corebanking.commission.domain.enums.CustomerDeserveType.PARTIAL_DESERVED;

@UtilityClass
public class CtrJobUtil {

    public BigDecimal getConvertedCurrencyAmount(BigDecimal tariffAmount, String tempTariffCurrency, String tempMinLimitCurrency, ConcurrentMap<String, BigDecimal> tellerRatesList) {
        if (ControlUtil.isNull(tariffAmount) || ControlUtil.isEmpty(tempTariffCurrency) || ControlUtil.isEmpty(tempMinLimitCurrency))
            return null;
        tempTariffCurrency = CommonUtil.toTL(tempTariffCurrency);
        tempMinLimitCurrency = CommonUtil.toTL(tempMinLimitCurrency);
        if (tempTariffCurrency.equals(tempMinLimitCurrency)) return tariffAmount;
        BigDecimal convertedTLAmount = tellerRatesList.get(tempTariffCurrency).multiply(tariffAmount);
        if (CommonUtil.isLocalCurrency(tempMinLimitCurrency)) return roundBigDecimal(convertedTLAmount, 2);
        return convertedTLAmount.divide(tellerRatesList.get(tempMinLimitCurrency), 2, RoundingMode.HALF_UP);
    }

    private BigDecimal roundBigDecimal(BigDecimal value, int places) {

        if (places < 0) throw new IllegalArgumentException();

        BigDecimal bd = new BigDecimal(String.valueOf(value));
        bd = bd.setScale(places, RoundingMode.HALF_UP);
        return bd;
    }

    public String getLimitControlStatus(CustomerTariffDefinitionDTO customerTariffDefinitionDTO, BigDecimal minLimit, String minLimitCurrency, ConcurrentMap<String, BigDecimal> tellerRatesList) {
        String limitControlStatus = CtrLimitControlStatus.LIMIT_UNDER.getKey();

        if (!StringUtils.isNumeric(customerTariffDefinitionDTO.getOperationCode())) {
            if (CustomerTariffDefinitionTypes.TARIFF_RATIO.getKey().equals(customerTariffDefinitionDTO.getType()) ||
                    CustomerTariffDefinitionTypes.BASE_PRICE.getKey().equals(customerTariffDefinitionDTO.getType())) {
                limitControlStatus = CtrLimitControlStatus.LIMIT_OVER.getKey();
            } else if (minLimit != null) {
                String tempTariffCurrency = CommonUtil.toTL(customerTariffDefinitionDTO.getCurrency());
                String tempMinLimitCurrency = CommonUtil.toTL(minLimitCurrency);
                BigDecimal tariffAmount;
                if (CustomerTariffDefinitionTypes.OPERATION_AMT_RATIO.getKey().equals(customerTariffDefinitionDTO.getType())) {
                    tariffAmount = customerTariffDefinitionDTO.getMinAmount();
                } else {
                    tariffAmount = ControlUtil.nvl(customerTariffDefinitionDTO.getAmount(), customerTariffDefinitionDTO.getMinAmount());
                }
                if (!tempMinLimitCurrency.equals(tempTariffCurrency))
                    tariffAmount = getConvertedCurrencyAmount(tariffAmount, tempTariffCurrency, tempMinLimitCurrency, tellerRatesList);
                limitControlStatus = Boolean.TRUE.equals(CustomerTariffDefinitionUtil.isGreaterEqualBigDecimal(tariffAmount, minLimit))
                        ? CtrLimitControlStatus.LIMIT_OVER.getKey() : CtrLimitControlStatus.LIMIT_UNDER.getKey();
            }
        }
        return limitControlStatus;
    }

    public CtrMinLimitDTO getMinLimitInfoAccordingToBasePriceDefinitions(List<BasePriceDefinitionDTO> basePriceDefinitionDTOList,
                                                                         ConcurrentMap<String, BigDecimal> tellerRatesList) {
        CtrMinLimitDTO ctrMinLimitDTO = new CtrMinLimitDTO();
        if (!ControlUtil.isEmpty(basePriceDefinitionDTOList)) {
            BasePriceDefinitionDTO lowestBasePriceDefinition = basePriceDefinitionDTOList
                    .stream()
                    .min(Comparator.comparing(item ->
                            getConvertedCurrencyAmount(item.getAmount(), item.getCurrency(), CURRENCY_CODE_TL, tellerRatesList)))
                    .orElse(new BasePriceDefinitionDTO());
            ctrMinLimitDTO.setMinLimit(lowestBasePriceDefinition.getAmount());
            ctrMinLimitDTO.setMinLimitCurrency(CommonUtil.toTL(lowestBasePriceDefinition.getCurrency()));
        }
        return ctrMinLimitDTO;
    }

    public CtrRuleDefinitionDTO getMatchedRuleDefinition(String sbuType, String customerDeserveType,
                                                         Integer undeservedArrivalCount, String limitControlStatus,
                                                         Map<String, List<CtrRuleDefinitionDTO>> cachedRuleDefinitionMap) {
        CtrRuleDefinitionDTO foundRuleDefinition = null;
        CtrRuleDefinitionDTO noLimitRuleDefinition = null;
        List<CtrRuleDefinitionDTO> cachedRuleDefinitions = cachedRuleDefinitionMap.get(sbuType);
        if (!Objects.isNull(cachedRuleDefinitions)) {
            for (CtrRuleDefinitionDTO ruleDefinition : cachedRuleDefinitions) {
                if (Objects.equals(customerDeserveType, ruleDefinition.getCustomerDeserveType()) &&
                        Objects.equals(undeservedArrivalCount, ruleDefinition.getUndeservedArrivalCount())) {
                    if (Objects.equals(limitControlStatus, ruleDefinition.getLimitControlStatus())) {
                        foundRuleDefinition = ruleDefinition;
                        break;
                    } else if (CtrLimitControlStatus.NO_LIMIT.getKey().equals(ruleDefinition.getLimitControlStatus())) {
                        noLimitRuleDefinition = ruleDefinition;
                    }
                }
            }
        }
        return Objects.isNull(foundRuleDefinition) ? noLimitRuleDefinition : foundRuleDefinition;
    }

    public CtrLimitDefinitionDTO getMatchedLimitDefinition(String operationCode, String sbuType,
                                                           String channelCode, String currency,
                                                           Map<String, List<CtrLimitDefinitionDTO>> cachedLimitDefinitionMap) {
        CtrLimitDefinitionDTO foundLimitDefinition = null;
        CtrLimitDefinitionDTO limitDefinitionWithoutCurrency = null;
        List<CtrLimitDefinitionDTO> cachedLimitDefinitions = cachedLimitDefinitionMap.get(operationCode);
        if (!Objects.isNull(cachedLimitDefinitions)) {
            for (CtrLimitDefinitionDTO limitDefinition : cachedLimitDefinitions) {
                if ((Objects.equals(sbuType, limitDefinition.getSbuType()) || Objects.isNull(limitDefinition.getSbuType())) &&
                        (Objects.equals(channelCode, limitDefinition.getChannelCode()) || Objects.isNull(limitDefinition.getChannelCode()))) {
                    limitDefinitionWithoutCurrency = limitDefinition;
                    if (Objects.equals(currency, limitDefinition.getCurrency()) || CommonConstants.TRUE_FLAG.equals(limitDefinition.getBasePriceFlag())) {
                        foundLimitDefinition = limitDefinition;
                        break;
                    }
                }
            }
        }
        return Objects.isNull(foundLimitDefinition) ? limitDefinitionWithoutCurrency : foundLimitDefinition;
    }

    public List<BasePriceDefinitionDTO> getMatchedBasePriceDefinition(CustomerTariffDefinitionDTO customerTariffDefinitionDTO, String sbuTypeCode, Map<String, List<BasePriceDefinitionDTO>> cachedBasePriceDefinitionMap) {
        return Optional.ofNullable(cachedBasePriceDefinitionMap.get(customerTariffDefinitionDTO.getOperationCode())).orElseGet(ArrayList::new)
                .stream().filter(basePricePredicate(customerTariffDefinitionDTO, sbuTypeCode)).collect(Collectors.toCollection(ArrayList::new));
    }

    private Predicate<BasePriceDefinitionDTO> basePricePredicate(CustomerTariffDefinitionDTO customerTariffDefinitionDTO, String sbuTypeCode){
        return item -> (
                (Objects.equals(sbuTypeCode, item.getSbuType()) || Objects.isNull(item.getSbuType())) &&
                        (Objects.equals(customerTariffDefinitionDTO.getChannelCode(), item.getChannelCode()) || Objects.isNull(item.getChannelCode())) &&
                        Objects.equals(customerTariffDefinitionDTO.getFeeId(), item.getFeeDefinitionId()) &&
                        (CustomerTariffDefinitionUtil.hasOverlappingRange(item.getMinOperationAmount(), item.getMaxOperationAmount(), customerTariffDefinitionDTO.getMinOperationAmount(), customerTariffDefinitionDTO.getMaxOperationAmount()))
        );
    }

    public CtrMinLimitDTO getMinLimitInformation(CtrProcessDefinitionDetailDTO ctrProcessDefinitionDetailDTO, CtrLimitDefinitionDTO ctrLimitDefinitionDTO,
                                                 CustomerTariffDefinitionDTO customerTariffDefinitionDTO, ConcurrentMap<String, BigDecimal> tellerRatesList,
                                                 Map<String, List<BasePriceDefinitionDTO>> cachedBasePriceDefinitionMap) {
        CtrMinLimitDTO ctrMinLimitDTO = new CtrMinLimitDTO();
        if (ctrLimitDefinitionDTO != null) {
            ctrMinLimitDTO.setMinLimitCurrency(ctrLimitDefinitionDTO.getCurrency());
            if (CommonConstants.TRUE_FLAG.equals(ctrLimitDefinitionDTO.getBasePriceFlag())) {
                List<BasePriceDefinitionDTO> basePriceDefinitionDTOS = getMatchedBasePriceDefinition(customerTariffDefinitionDTO,
                        ctrProcessDefinitionDetailDTO.getSbuType(),
                        cachedBasePriceDefinitionMap);
                ctrMinLimitDTO = getMinLimitInfoAccordingToBasePriceDefinitions(basePriceDefinitionDTOS, tellerRatesList);
            } else {
                ctrMinLimitDTO.setMinLimit(ctrLimitDefinitionDTO.getMinLimit());
            }
        }
        return ctrMinLimitDTO;
    }

    public BigDecimal getTariffDefinitionAmount(CtrProcessDefinitionDetailDTO ctrProcessDefinitionDetailDTO) {
        return ctrProcessDefinitionDetailDTO.getExemptionType().equals(CtrExemptionType.NO_COMMISSION.getKey())
                ? BigDecimal.ZERO : null;
    }

    public String getDeserveType(CustomerDeserveOutputDTO customerDeserveOutputDTO) {
        String deserveType;
        if (PARTIAL_DESERVED.equals(customerDeserveOutputDTO.getCustomerDeserveType())) {
            deserveType = DESERVE.getKey(); //we accept partial deserved as deserve in ctr
        } else {
            deserveType = customerDeserveOutputDTO.getCustomerDeserveType().getKey();
        }

        return deserveType;
    }
}

package com.ykb.corebanking.commission.batch.utils;

import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Lazy
@Component
public class CustomJobParameters<K,V> {
    private final Map<K, V> parameters;

    public CustomJobParameters() {
        this.parameters = new ConcurrentHashMap<>();
    }

    public Map<K, V> getParameters() {
        return parameters;
    }

    public void addParameter(K key, V value){
        parameters.put(key, value);
    }

    public V getByKey(K key){
        return parameters.get(key);
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr;

import com.ykb.corebanking.commission.batch.common.ExecuteSqlScriptTasklet;
import com.ykb.corebanking.commission.batch.common.ItemFailureLoggerListener;
import com.ykb.corebanking.commission.batch.configuration.BaseJobConfiguration;
import com.ykb.corebanking.commission.batch.configuration.CommonJobExecutionListener;
import com.ykb.corebanking.commission.batch.configuration.JobConfigurationParameter;
import com.ykb.corebanking.commission.batch.jobs.ctr.decider.CtrBatchWorkTypeDecider;
import com.ykb.corebanking.commission.batch.jobs.ctr.decider.CtrExecuteDecider;
import com.ykb.corebanking.commission.batch.jobs.ctr.decider.CtrSimulationTruncateDecider;
import com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchException;
import com.ykb.corebanking.commission.batch.jobs.ctr.listener.CtrJobExecutionListener;
import com.ykb.corebanking.commission.batch.jobs.ctr.listener.CtrPreparationStepListener;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.action.CtrActionWriter;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.cancelapproval.CtrCancelApprovalWriter;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.notification.CtrNotificationTasklet;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation.CtrNormalPreparationProcessor;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation.CtrNormalPreparationWriter;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation.CtrSimulationPreparationProcessor;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation.CtrSimulationPreparationWriter;
import com.ykb.corebanking.commission.batch.jobs.ctr.steps.processdefinition.CtrProcessDefinitionTasklet;
import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.domain.data.ctr.CtrClientPortfolioDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrOperationResultDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrOperationResultDetailDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrSimulationResultDTO;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefApprovalDTO;
import com.ykb.corebanking.commission.domain.enums.CtrBatchOperationMode;
import com.ykb.corebanking.commission.domain.enums.CtrBatchOperationStatus;
import com.ykb.corebanking.commission.domain.enums.CtrProcessDefinitionStatus;
import com.ykb.corebanking.commission.domain.port.ctr.CtrPort;
import com.ykb.corebanking.commission.infrastructure.common.util.SqlUtils;
import com.ykb.corebanking.commission.infrastructure.configuration.DefinitionChainedTransactionManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.job.builder.FlowBuilder;
import org.springframework.batch.core.job.flow.Flow;
import org.springframework.batch.core.job.flow.support.SimpleFlow;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.integration.async.AsyncItemProcessor;
import org.springframework.batch.integration.async.AsyncItemWriter;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.JdbcPagingItemReader;
import org.springframework.batch.item.database.Order;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.database.builder.JdbcPagingItemReaderBuilder;
import org.springframework.batch.item.support.CompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import org.springframework.core.io.Resource;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.*;
import java.util.concurrent.Future;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.*;
import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchReaderQueryParts.*;
import static com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchExceptionMessages.NO_RULE_FOR_PROCESS_SBU_TYPE_MESSAGE;
import static com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction.*;

@Slf4j
@Lazy
@Configuration
public class CtrJobConfiguration extends BaseJobConfiguration {

    private final DataSource commissionDatasource;
    private final DefinitionChainedTransactionManager chainedTransactionManager;
    private final PlatformTransactionManager commissionTransactionManager;
    private final Resource updateOperationDetailResource;
    private final Resource truncateSimulationTableResource;

    private Boolean disableNormalOperationPreparationStep;
    private Boolean disableCancelApprovalStep;
    private Boolean disableActionStep;
    private Boolean disableCtrNotificationStep;

    @Autowired
    public CtrJobConfiguration(JobRepository jobRepository,
                               CommonJobExecutionListener commonJobExecutionListener, JobConfigurationParameter jobConfigurationParameter,
                               CustomJobParameters<String, Object> customJobParameters, @Qualifier("commissionDatasource") DataSource commissionDatasource,
                               @Qualifier("chainedTransactionManager") DefinitionChainedTransactionManager chainedTransactionManager,
                               @Qualifier("transactionManager") PlatformTransactionManager commissionTransactionManager,
                               @Value("classpath:sql/customertariffreview/updateOperationDetailStatus.sql") Resource updateOperationDetailResource,
                               @Value("classpath:sql/customertariffreview/truncateSimulationTable.sql") Resource truncateSimulationTableResource,
                               ItemFailureLoggerListener<? extends Object, ? extends Object> itemFailureLoggerListener, ApplicationArguments applicationArguments,
                               @Value(value = "${ctr.disableNormalOperationPreparationStep:false}") Boolean disableNormalOperationPreparationStep,
                               @Value(value = "${ctr.disableCancelApprovalStep:false}") Boolean disableCancelApprovalStep,
                               @Value(value = "${ctr.disableActionStep:false}") Boolean disableActionStep,
                               @Value(value = "${ctr.disableCtrNotificationStep:false}") Boolean disableCtrNotificationStep) {
        super(jobRepository, commonJobExecutionListener, jobConfigurationParameter, customJobParameters, itemFailureLoggerListener,applicationArguments);
        this.commissionDatasource = commissionDatasource;
        this.chainedTransactionManager = chainedTransactionManager;
        this.commissionTransactionManager = commissionTransactionManager;
        this.updateOperationDetailResource = updateOperationDetailResource;
        this.truncateSimulationTableResource = truncateSimulationTableResource;
        this.disableNormalOperationPreparationStep = disableNormalOperationPreparationStep;
        this.disableCancelApprovalStep = disableCancelApprovalStep;
        this.disableActionStep = disableActionStep;
        this.disableCtrNotificationStep = disableCtrNotificationStep;
    }

    @Bean
    public Job ctrJob(CtrPort ctrPort, CtrJobExecutionListener ctrJobExecutionListener, CtrPreparationStepListener preparationStepListener) throws Exception {
        return getCommonJobBuilder(CTR_JOB)
                .listener(ctrJobExecutionListener)
                .start(mainFlow(ctrPort, preparationStepListener))
                .end()
                .build();
    }

    @Bean
    public Flow mainFlow(CtrPort ctrPort, CtrPreparationStepListener preparationStepListener) throws Exception {
        return new FlowBuilder<SimpleFlow>("mainFlow")
                .start(ctrProcessDefinitionStep())
                .next(workTypeDecider())
                .on(CtrBatchOperationMode.OPERATION.getKey())
                .to(normalOperationFlow(ctrPort, preparationStepListener))
                .from(workTypeDecider())
                .on(CtrBatchOperationMode.SIMULATION.getKey())
                .to(simulationOperationFlow(ctrPort,preparationStepListener))
                .end();
    }

    @Bean
    public Flow normalOperationFlow(CtrPort ctrPort, CtrPreparationStepListener preparationStepListener) throws Exception {
        FlowBuilder<SimpleFlow> operationSubFlow = new FlowBuilder<>("operationSubFlow");
        if(!Boolean.TRUE.equals(disableNormalOperationPreparationStep)){
            operationSubFlow.next(normalOperationPreparationStep(ctrPort, preparationStepListener));
        }
        if(!Boolean.TRUE.equals(disableCancelApprovalStep)){
            operationSubFlow.next(cancelApprovalStep());
        }
        if(!Boolean.TRUE.equals(disableActionStep)){
            operationSubFlow.next(actionStep());
        }
        if(!Boolean.TRUE.equals(disableCtrNotificationStep)){
            operationSubFlow.next(ctrNotificationStep());
        }

        return new FlowBuilder<SimpleFlow>("operationFlow")
                .start(ctrExecuteDecider())
                .on(OK)
                .to(operationSubFlow.end())
                .from(ctrExecuteDecider())
                .on(NOK)
                .stop()
                .end();
    }

    @Bean
    public Flow simulationOperationFlow(CtrPort ctrPort, CtrPreparationStepListener preparationStepListener) throws Exception {
        return new FlowBuilder<SimpleFlow>("simulationFlow")
                .start(ctrExecuteDecider())
                .on(OK)
                .to(simulationTruncateDecider())
                .on(CtrProcessDefinitionStatus.WAITING.getKey())
                .to(simulationTruncateStep())
                .next(simulationOperationPreparationStep(ctrPort, preparationStepListener))
                .from(simulationTruncateDecider())
                .on(CtrProcessDefinitionStatus.FAILURE.getKey())
                .to(simulationOperationPreparationStep(ctrPort, preparationStepListener))
                .from(ctrExecuteDecider())
                .on(NOK)
                .end()
                .end();
    }

    @Bean
    public Step ctrProcessDefinitionStep() {
        return generateTaskletStep(PROCESS_DEFINITION_STEP,
                ctrProcessDefinitionTasklet(), commissionTransactionManager)
                .build();
    }

    @Bean
    public Step normalOperationPreparationStep(CtrPort ctrPort, CtrPreparationStepListener preparationStepListener) throws Exception {
        return getCommonStepBuilder(NORMAL_OPERATION_STEP)
                .listener(preparationStepListener)
                .<CtrClientPortfolioDTO, Future<CtrOperationResultDTO>>chunk(config.getSteps().get(NORMAL_OPERATION_STEP).getChunkSize(), commissionTransactionManager)
                .reader(ctrPreparationJdbcPagingCursorItemReader(ctrPort))
                .processor(asyncCtrNormalPreparationProcessor())
                .writer(asyncCtrNormalPreparationWriter())
                .build();
    }

    @Bean
    public Step actionStep() {

        List<ItemWriter<? super CtrOperationResultDetailDTO>> writers = new ArrayList<>();
        writers.add(ctrOperationDetailStatusWriter());
        writers.add(ctrActionWriter());

        CompositeItemWriter<CtrOperationResultDetailDTO> writer = new CompositeItemWriter<>();
        writer.setDelegates(writers);

        return getCommonStepBuilder(ACTION_STEP)
                .<CtrOperationResultDetailDTO,CtrOperationResultDetailDTO>chunk(config.getSteps().get(ACTION_STEP).getChunkSize(), chainedTransactionManager)
                .reader(ctrActionJdbcPagingCursorItemReader())
                .writer(writer)
                .listener(itemFailureLoggerListener)
                .taskExecutor(commonBatchTaskExecutor())
                .stepOperations(repeatTemplate(commonBatchTaskExecutor(), config.getSteps().get(ACTION_STEP).getThrottleLimit()))
                .build();
    }

    @Bean
    public Step ctrNotificationStep() {
        return generateTaskletStep(NOTIFICATION_STEP,
                ctrNotificationTasklet(), commissionTransactionManager)
                .build();
    }

    @Bean
    public Step simulationOperationPreparationStep(CtrPort ctrPort, CtrPreparationStepListener preparationStepListener) throws Exception {
        return getCommonStepBuilder(SIMULATION_OPERATION_STEP)
                .listener(preparationStepListener)
                .<CtrClientPortfolioDTO, Future<List<CtrSimulationResultDTO>>>chunk(config.getSteps().get(SIMULATION_OPERATION_STEP).getChunkSize(), commissionTransactionManager)
                .reader(ctrPreparationJdbcPagingCursorItemReader(ctrPort))
                .processor(asyncCtrSimulationPreparationProcessor())
                .writer(asyncCtrSimulationPreparationWriter())
                .build();
    }

    @Bean
    public Step simulationTruncateStep(){
        return generateTaskletStep(SIMULATION_TRUNCATE_STEP,
                truncateSimulationTableTasklet(), commissionTransactionManager)
                .build();
    }

    @Bean
    public Step cancelApprovalStep() {
        return getCommonStepBuilder(CANCEL_APPROVAL_STEP)
                .<CustomerTariffDefApprovalDTO, CustomerTariffDefApprovalDTO>chunk(config.getSteps().get(CANCEL_APPROVAL_STEP).getChunkSize(), commissionTransactionManager)
                .reader(ctrCancelApprovalJdbcPagingCursorItemReader())
                .writer(ctrCancelApprovalWriter())
                .listener(itemFailureLoggerListener)
                .taskExecutor(commonBatchTaskExecutor())
                .stepOperations(repeatTemplate(commonBatchTaskExecutor(), config.getSteps().get(CANCEL_APPROVAL_STEP).getThrottleLimit()))
                .build();
    }

    @Bean
    public CtrProcessDefinitionTasklet ctrProcessDefinitionTasklet(){
        return new CtrProcessDefinitionTasklet();
    }

    @Bean
    @StepScope
    public JdbcPagingItemReader<CtrClientPortfolioDTO> ctrPreparationJdbcPagingCursorItemReader(CtrPort ctrPort) throws CtrBatchException {
        CtrProcessDefinitionDTO ctrProcessDefinitionDTO = (CtrProcessDefinitionDTO)customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO);
        boolean isOperation = CtrBatchOperationMode.OPERATION.getKey().equals(customJobParameters.getByKey(OPERATION_MODE_NAME));

        List<String> definedRuleSbuTypeList = ctrPort.getRuleDefinitionSbuTypeList();
        List<String> definedProcessSbuTypeList = new ArrayList<>(ctrPort.getSbuListOfWaitingProcessDefinition(ctrProcessDefinitionDTO.getId()).keySet());
        definedRuleSbuTypeList.retainAll(definedProcessSbuTypeList);
        if(definedRuleSbuTypeList.isEmpty()){
            log.error("Probably no rule defined for sbu type list in process detail");
            throw new CtrBatchException(NO_RULE_FOR_PROCESS_SBU_TYPE_MESSAGE);
        }

        Map<String, Object> parameterValues = new HashMap<>();
        parameterValues.put("sbuTypeList", definedRuleSbuTypeList);

        StringBuilder preparationWhereCondition = new StringBuilder(PREPARATION_WHERE);
        if(CtrProcessDefinitionStatus.FAILURE.getKey().equals(ctrProcessDefinitionDTO.getStatus())){
            parameterValues.put("ctrProcessDefinitionId", ctrProcessDefinitionDTO.getId());
            if(isOperation){
                preparationWhereCondition.append(PREPARATION_OPERATION_WHERE_FAIL_CONDITION);
            }else{
                preparationWhereCondition.append(SIMULATION_OPERATION_WHERE_FAIL_CONDITION);
            }
        }

        String stepName = isOperation ? NORMAL_OPERATION_STEP : SIMULATION_OPERATION_STEP;

        return new JdbcPagingItemReaderBuilder<CtrClientPortfolioDTO>()
                .name("ctrPreparationJdbcPagingCursorItemReader")
                .dataSource(commissionDatasource)
                .selectClause(PREPARATION_SELECT)
                .fromClause(PREPARATION_FROM)
                .whereClause(preparationWhereCondition.toString())
                .sortKeys(Collections.singletonMap("CLIENT_NO", Order.ASCENDING))
                .parameterValues(parameterValues)
                .rowMapper(new BeanPropertyRowMapper<>(CtrClientPortfolioDTO.class))
                .pageSize(config.getSteps().get(stepName).getPageSize())
                .fetchSize(config.getSteps().get(stepName).getFetchSize())
                .build();
    }


    @Bean
    @StepScope
    public JdbcPagingItemReader<CtrOperationResultDetailDTO> ctrActionJdbcPagingCursorItemReader() {
        Map<String, Object> parameterValues = new HashMap<>();
        parameterValues.put(PROCESS_DEFINITION_ID, ((CtrProcessDefinitionDTO)customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO)).getId());
        parameterValues.put("actionTypeList", Arrays.asList(DELETE.getKey(), NO_ACTION.getKey(), UPDATE_BASEPRICE.getKey()));

        return new JdbcPagingItemReaderBuilder<CtrOperationResultDetailDTO>()
                .name("ctrActionJdbcPagingCursorItemReader")
                .dataSource(commissionDatasource)
                .selectClause(ACTION_SELECT)
                .fromClause(ACTION_FROM)
                .whereClause(ACTION_WHERE)
                .sortKeys(Collections.singletonMap("ID", Order.ASCENDING))
                .parameterValues(parameterValues)
                .rowMapper(new BeanPropertyRowMapper<>(CtrOperationResultDetailDTO.class))
                .pageSize(config.getSteps().get(ACTION_STEP).getPageSize())
                .fetchSize(config.getSteps().get(ACTION_STEP).getFetchSize())
                .saveState(false)
                .build();
    }

    @Bean
    @StepScope
    public JdbcPagingItemReader<CustomerTariffDefApprovalDTO> ctrCancelApprovalJdbcPagingCursorItemReader() {
        Map<String, Object> parameterValues = new HashMap<>();
        parameterValues.put(PROCESS_DEFINITION_ID, ((CtrProcessDefinitionDTO)customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO)).getId());

        return new JdbcPagingItemReaderBuilder<CustomerTariffDefApprovalDTO>()
                .name("ctrCancelApprovalJdbcPagingCursorItemReader")
                .dataSource(commissionDatasource)
                .selectClause(CANCEL_APPROVAL_SELECT)
                .fromClause(CANCEL_APPROVAL_FROM)
                .whereClause(CANCEL_APPROVAL_WHERE)
                .sortKeys(Collections.singletonMap("ID", Order.ASCENDING))
                .parameterValues(parameterValues)
                .rowMapper(new BeanPropertyRowMapper<>(CustomerTariffDefApprovalDTO.class))
                .pageSize(config.getSteps().get(CANCEL_APPROVAL_STEP).getPageSize())
                .fetchSize(config.getSteps().get(CANCEL_APPROVAL_STEP).getFetchSize())
                .saveState(false)
                .build();
    }

    @Bean
    @StepScope
    public CtrNormalPreparationWriter ctrNormalPreparationWriter(){
        return new CtrNormalPreparationWriter();
    }

    @Bean
    public AsyncItemWriter<CtrOperationResultDTO> asyncCtrNormalPreparationWriter() throws Exception {
        AsyncItemWriter<CtrOperationResultDTO> asyncItemWriter = new AsyncItemWriter<>();
        asyncItemWriter.setDelegate(ctrNormalPreparationWriter());
        asyncItemWriter.afterPropertiesSet();
        return asyncItemWriter;
    }

    @Bean
    @StepScope
    public CtrNormalPreparationProcessor ctrNormalPreparationProcessor(){
        return new CtrNormalPreparationProcessor();
    }

    @Bean
    public AsyncItemProcessor<CtrClientPortfolioDTO,CtrOperationResultDTO> asyncCtrNormalPreparationProcessor() throws Exception {

        AsyncItemProcessor<CtrClientPortfolioDTO,CtrOperationResultDTO> asyncItemProcessor = new AsyncItemProcessor<>();
        asyncItemProcessor.setDelegate(ctrNormalPreparationProcessor());
        asyncItemProcessor.setTaskExecutor(commonBatchTaskExecutor());
        asyncItemProcessor.afterPropertiesSet();
        return asyncItemProcessor;
    }

    @Bean
    @StepScope
    public CtrActionWriter ctrActionWriter(){
        return new CtrActionWriter();
    }

    @Bean
    @StepScope
    public JdbcBatchItemWriter<CtrOperationResultDetailDTO> ctrOperationDetailStatusWriter() {
        JdbcBatchItemWriterBuilder<CtrOperationResultDetailDTO> writerBuilder = new JdbcBatchItemWriterBuilder<>();
        writerBuilder.dataSource(commissionDatasource);
        writerBuilder.namedParametersJdbcTemplate(new NamedParameterJdbcTemplate(commissionDatasource));
        writerBuilder.sql(SqlUtils.readSql(updateOperationDetailResource));
        writerBuilder.itemSqlParameterSourceProvider(item -> new MapSqlParameterSource()
                .addValue("id", item.getId())
                .addValue("status", CtrBatchOperationStatus.COMPLETED.getKey()));

        return writerBuilder.build();
    }

    @Bean
    @StepScope
    public CtrSimulationPreparationWriter ctrSimulationPreparationWriter(){
        return new CtrSimulationPreparationWriter();
    }

    @Bean
    public AsyncItemWriter<List<CtrSimulationResultDTO>> asyncCtrSimulationPreparationWriter() throws Exception {
        AsyncItemWriter<List<CtrSimulationResultDTO>> asyncItemWriter = new AsyncItemWriter<>();
        asyncItemWriter.setDelegate(ctrSimulationPreparationWriter());
        asyncItemWriter.afterPropertiesSet();
        return asyncItemWriter;
    }

    @Bean
    @StepScope
    public CtrCancelApprovalWriter ctrCancelApprovalWriter(){
        return new CtrCancelApprovalWriter();
    }

    @Bean
    @StepScope
    public CtrSimulationPreparationProcessor ctrSimulationPreparationProcessor(){
        return new CtrSimulationPreparationProcessor();
    }

    @Bean
    public AsyncItemProcessor<CtrClientPortfolioDTO,List<CtrSimulationResultDTO>> asyncCtrSimulationPreparationProcessor() throws Exception {
        AsyncItemProcessor<CtrClientPortfolioDTO,List<CtrSimulationResultDTO>> asyncItemProcessor = new AsyncItemProcessor<>();
        asyncItemProcessor.setDelegate(ctrSimulationPreparationProcessor());
        asyncItemProcessor.setTaskExecutor(commonBatchTaskExecutor());
        asyncItemProcessor.afterPropertiesSet();
        return asyncItemProcessor;
    }

    @Bean
    public CtrBatchWorkTypeDecider workTypeDecider(){
        return new CtrBatchWorkTypeDecider();
    }

    @Bean
    public CtrSimulationTruncateDecider simulationTruncateDecider(){
        return new CtrSimulationTruncateDecider();
    }

    @Bean
    public CtrExecuteDecider ctrExecuteDecider(){
        return new CtrExecuteDecider();
    }

    @Bean
    public Tasklet truncateSimulationTableTasklet(){
        return new ExecuteSqlScriptTasklet(SqlUtils.readSql(truncateSimulationTableResource), new NamedParameterJdbcTemplate(commissionDatasource));
    }

    @Bean
    public CtrNotificationTasklet ctrNotificationTasklet(){
        return new CtrNotificationTasklet();
    }

}


package com.ykb.corebanking.commission.batch.jobs.ctr.base;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class CtrBatchConstants {
    public static final String CTR_PROCESS_DEFINITION_DTO = "ctrProcessDefinitionDTO";

    public static final String CTR_CURRENCY_CONVERT = "ctrCurrencyConverter";

    public static final String OPERATION_MODE_NAME = "OPERATION_MODE_NAME";

    public static final String SCREEN_NAME = "MGG";

    public static final String BASE_PRICE = "BASE_PRICE";

    public static final String OK = "OK";

    public static final String NOK = "NOK";

    public static final String CTR_JOB = "ctrJob";

    public static final String ACTION_STEP = "action";

    public static final String CANCEL_APPROVAL_STEP = "cancelApproval";

    public static final String NORMAL_OPERATION_STEP = "normalOperationPreparation";

    public static final String SIMULATION_OPERATION_STEP = "simulationOperationPreparation";

    public static final String NOTIFICATION_STEP = "notification";

    public static final String PROCESS_DEFINITION_STEP = "processDefinition";

    public static final String SIMULATION_TRUNCATE_STEP = "simulationTruncate";

    public static final String PROCESS_DEFINITION_ID = "processDefinitionId";
}

package com.ykb.corebanking.commission.batch.jobs.ctr.base;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class CtrBatchMessages {
    public static final String CANCEL_TARIFF_DEFINITION_MESSAGE = "Müşteri için MGG sürecinin başlatılması.";
}

package com.ykb.corebanking.commission.batch.jobs.ctr.base;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class CtrBatchReaderQueryParts {


    public static final String PREPARATION_SELECT = "cl.CUSTOMER_NO       as CLIENT_NO," +
            "       cl.BRANCH_CODE     as CLIENT_BRANCH_CODE," +
            "       rpm.PORTFOLIO_CODE as PORTFOLIO_CODE," +
            "       rpm.SBU_TYPE       as PORTFOLIO_SBU_TYPE," +
            "       cl.SBU_TYPE        as SBU_TYPE," +
            "       rpm.BRANCH_CODE    as PORTFOLIO_BRANCH_CODE";
    public static final String PREPARATION_FROM = "COMMISSION.REPLICATED_CUSTOMER           cl," +
            "       COMMISSION.REPLICATED_PORTFOLIO_MANAGER rpm";
    public static final String PREPARATION_WHERE = "cl.BRANCH_CODE NOT IN" +
            "       (SELECT value" +
            "          FROM COMMISSION.GENERAL_PARAMETERS" +
            "         WHERE name = 'BRANCH_RULES' and status = 'A')" +
            "   AND rpm.BRANCH_CODE NOT IN" +
            "       (SELECT value" +
            "          FROM COMMISSION.GENERAL_PARAMETERS" +
            "         WHERE name = 'PORTFOLIO_BRANCH_RULES' and status = 'A')" +
            "   AND cl.PORTFOLIO_CODE = rpm.PORTFOLIO_CODE" +
            "   AND 'A' = rpm.STATUS" +
            "   AND cl.STATUS_CODE != 'D' " +
            "   AND cl.SBU_TYPE IN (:sbuTypeList)" +
            "   AND NOT EXISTS (SELECT *" +
            "          FROM COMMISSION.EXCEPTIONAL_CLIENT" +
            "         where GROUP_NAME = 'MOTTAN_PFM'" +
            "           and CLIENT_NO = cl.CUSTOMER_NO)" +
            "   AND EXISTS (SELECT *" +
            "          FROM COMMISSION.CUSTOMER_TARIFF_DEFINITION ctd" +
            "           where ctd.client_no = cl.CUSTOMER_NO" +
            "           AND ctd.PRODUCT_CODE is null" +
            "           AND ctd.END_DATE > TRUNC(SYSDATE)" +
            "           AND ctd.DEMAND_LOCATION_CODE <> 'HQ'" +
            "           AND ctd.operation_code != '99998')";
    public static final String PREPARATION_OPERATION_WHERE_FAIL_CONDITION = "   AND NOT EXISTS" +
            " (SELECT * FROM COMMISSION.CTR_OPERATION_RESULT cor" +
            "         WHERE cor.CTR_PROCESS_DEFINITION_ID = :ctrProcessDefinitionId" +
            "           AND cor.CLIENT_NO = cl.CUSTOMER_NO)";
    public static final String SIMULATION_OPERATION_WHERE_FAIL_CONDITION = "   AND NOT EXISTS" +
            " (SELECT *" +
            "          FROM COMMISSION.CTR_SIMULATION_RESULT csr" +
            "         WHERE csr.CTR_PROCESS_DEFINITION_ID = :ctrProcessDefinitionId" +
            "           AND csr.CLIENT_NO = cl.CUSTOMER_NO)";

    public static final String ACTION_SELECT = "*";
    public static final String ACTION_FROM = "COMMISSION.CTR_OPERATION_RESULT_DETAIL        cord";
    public static final String ACTION_WHERE = "cord.STATUS = 'WA'" +
            "   AND cord.ACTION IN (:actionTypeList)" +
            "   AND EXISTS" +
            " (SELECT *" +
            "          FROM COMMISSION.CTR_OPERATION_RESULT cor" +
            "         WHERE cor.CTR_PROCESS_DEFINITION_ID = :processDefinitionId" +
            "           AND cor.ID = cord.CTR_OPERATION_RESULT_ID)";

    public static final String CANCEL_APPROVAL_SELECT = "*";
    public static final String CANCEL_APPROVAL_FROM = "commission.customer_tariff_def_approval ctda";
    public static final String CANCEL_APPROVAL_WHERE = "ctda.client_no in" +
            " (select client_no from commission.ctr_operation_result cor where cor.CTR_PROCESS_DEFINITION_ID = :processDefinitionId)"+
            " AND ctda.source_application in ('MOTTAN','TOMOK')" +
            " AND ctda.status_code = 'W'";
}
	
	
package com.ykb.corebanking.commission.batch.jobs.ctr.decider;

import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.beans.factory.annotation.Autowired;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.OPERATION_MODE_NAME;

public class CtrBatchWorkTypeDecider implements JobExecutionDecider {

    @Autowired
    CustomJobParameters<String, Object> customJobParameters;

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {

        return new FlowExecutionStatus((String) customJobParameters.getByKey(OPERATION_MODE_NAME));
    }
}


package com.ykb.corebanking.commission.batch.jobs.ctr.decider;

import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.beans.factory.annotation.Autowired;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.*;

public class CtrExecuteDecider implements JobExecutionDecider {

    @Autowired
    CustomJobParameters<String, Object> customJobParameters;

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {

        return new FlowExecutionStatus(customJobParameters
                .getByKey(CTR_PROCESS_DEFINITION_DTO) != null ? OK : NOK);
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.decider;

import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.beans.factory.annotation.Autowired;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_PROCESS_DEFINITION_DTO;

public class CtrSimulationTruncateDecider implements JobExecutionDecider {

    @Autowired
    CustomJobParameters<String, Object> customJobParameters;

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {

        return new FlowExecutionStatus(((CtrProcessDefinitionDTO)customJobParameters
                .getByKey(CTR_PROCESS_DEFINITION_DTO)).getStatus());
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.exception;

public class CtrBatchException extends Exception{
    public CtrBatchException(String message) {
        super(message);
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.exception;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class CtrBatchExceptionMessages {

    public static final String NO_RULE_FOR_SBU_TYPE_MESSAGE = "Portföy SBU'ya ait kural tanımı bulunamadı: " +
            "(portfolio sbu type: %s, deserve flag: %s, undeserved arrival count: %d, client no: %d, client sbu type: %s)";

    public static final String NO_RULE_FOR_PROCESS_SBU_TYPE_MESSAGE = "İşlenecek SBU listesi boş. Muhtemelen iş tanımında yer alan" +
            " SBU'lardan hiçbiri için kural tanımı yapılmadı.";

    public static final String NOTIFICATION_SERVICE_FAILED = "Bildirim servisi başarılı olmadı.";

}

package com.ykb.corebanking.commission.batch.jobs.ctr.listener;

import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import com.ykb.corebanking.commission.domain.enums.CtrProcessDefinitionStatus;
import com.ykb.corebanking.commission.domain.port.ctr.CtrPort;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_PROCESS_DEFINITION_DTO;


@Slf4j
@Component
@Lazy
public class CtrJobExecutionListener implements JobExecutionListener {

    @Autowired
    private CtrPort ctrPort;

    @Autowired
    private CustomJobParameters<String, Object> customJobParameters;

    @Override
    public void beforeJob(JobExecution jobExecution) {
        //before job
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        CtrProcessDefinitionDTO ctrProcessDefinitionDTO = (CtrProcessDefinitionDTO)customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO);
        if(ctrProcessDefinitionDTO == null) return;
        String status;
        if(jobExecution.getExitStatus().equals(ExitStatus.COMPLETED)){
            status = CtrProcessDefinitionStatus.SUCCESS.getKey();
        }else{
            status = CtrProcessDefinitionStatus.FAILURE.getKey();
        }
        ctrPort.updateCtrProcessDefinitionStatusByJdbc(ctrProcessDefinitionDTO.getId(), status); // need to do this without using jpa because it's out of transaction boundary
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.listener;

import com.ykb.corebanking.commission.infrastructure.configuration.CustomerTariffReviewCacheConfig;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;


@Component
@Lazy
@AllArgsConstructor
public class CtrPreparationStepListener implements StepExecutionListener {

    private final CustomerTariffReviewCacheConfig customerTariffReviewCacheConfig;

    @Override
    public void beforeStep(StepExecution stepExecution) {
        //NO NEED
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        customerTariffReviewCacheConfig.evictCustomerTariffReviewBatchCaches(); //to save memory
        return stepExecution.getExitStatus();
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.steps.action;

import com.ykb.corebanking.commission.domain.constants.CustomerTariffReviewConstants;
import com.ykb.corebanking.commission.domain.data.ctr.CtrOperationResultDetailDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefinitionDTO;
import com.ykb.corebanking.commission.domain.domainmodel.customertariffedifinition.CustomerTariffDefinitionDeleteDomainModel;
import com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction;
import com.ykb.corebanking.commission.domain.port.customertariffdefinition.CustomerTariffDefinitionPort;
import com.ykb.corebanking.commission.domain.port.customertariffdefinition.CustomerTariffLimitedRelationPort;
import com.ykb.corebanking.commission.domain.port.limitedtariffdefinition.LimitedTariffDefinitionPort;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.BASE_PRICE;
import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.SCREEN_NAME;

public class CtrActionWriter implements ItemWriter<CtrOperationResultDetailDTO> {

    @Autowired
    private CustomerTariffDefinitionPort customerTariffDefinitionPort;
    @Autowired
    private LimitedTariffDefinitionPort limitedTariffDefinitionPort;
    @Autowired
    private CustomerTariffLimitedRelationPort customerTariffLimitedRelationPort;

    @Override
    public void write(Chunk<? extends CtrOperationResultDetailDTO> ctrOperationResultDetailDTOList) throws Exception {
        Map<String,List<CtrOperationResultDetailDTO>> ctrOperationResultDetailWithActionDTO = new HashMap<>();
        for(CtrOperationResultDetailDTO ctrOperationResultDetailDTO : ctrOperationResultDetailDTOList){
            List<CtrOperationResultDetailDTO> temp;
            if((temp = ctrOperationResultDetailWithActionDTO.get(ctrOperationResultDetailDTO.getAction())) == null){
                temp = new ArrayList<>();
            }
            temp.add(ctrOperationResultDetailDTO);
            ctrOperationResultDetailWithActionDTO.put(ctrOperationResultDetailDTO.getAction(), temp);
        }

        List<CtrOperationResultDetailDTO> ctrOperationResultActionList;
        List<CustomerTariffDefinitionDTO> customerTariffDefinitionDTOList;
        if((ctrOperationResultActionList = ctrOperationResultDetailWithActionDTO.get(CtrBatchTariffDefinitionAction.DELETE.getKey())) != null ){
            List<Long> idList = getCustomerTariffDefinitionIdList(ctrOperationResultActionList);

            CustomerTariffDefinitionDeleteDomainModel.getInstance(customerTariffDefinitionPort, limitedTariffDefinitionPort, customerTariffLimitedRelationPort)
                    .deleteCustomerTariffDefinitionWithLimitedDefinitions(idList, CustomerTariffReviewConstants.SYSTEM_GEN);
        }
        if((ctrOperationResultActionList = ctrOperationResultDetailWithActionDTO.get(CtrBatchTariffDefinitionAction.NO_ACTION.getKey())) != null ){
            customerTariffDefinitionDTOList = prepareCustomerTariffDefinitionDTOForNoAction(getCustomerTariffDefinitionDTOList(ctrOperationResultActionList));
            customerTariffDefinitionPort.updateCustomerTariffDefinitionList(customerTariffDefinitionDTOList, CustomerTariffReviewConstants.SYSTEM_GEN);
        }

        if((ctrOperationResultActionList = ctrOperationResultDetailWithActionDTO.get(CtrBatchTariffDefinitionAction.UPDATE_BASEPRICE.getKey())) != null){
            customerTariffDefinitionDTOList = prepareCustomerTariffDefinitionDTOForUpdateBasePriceAction(getCustomerTariffDefinitionDTOList(ctrOperationResultActionList));
            customerTariffDefinitionPort.updateCustomerTariffDefinitionList(customerTariffDefinitionDTOList, CustomerTariffReviewConstants.SYSTEM_GEN);
        }
    }

    private List<CustomerTariffDefinitionDTO> getCustomerTariffDefinitionDTOList(List<CtrOperationResultDetailDTO> ctrOperationResultActionList ){
        List<Long> idList = getCustomerTariffDefinitionIdList(ctrOperationResultActionList);
        return getCustomerTariffDefinitionDTOListFromIdList(idList);
    }

    private List<Long> getCustomerTariffDefinitionIdList(List<CtrOperationResultDetailDTO> ctrOperationResultDetailList){
        return ctrOperationResultDetailList.stream().map(CtrOperationResultDetailDTO::getCustomerTariffDefinitonId).toList();
    }

    private  List<CustomerTariffDefinitionDTO> getCustomerTariffDefinitionDTOListFromIdList(List<Long> idList ){
        return customerTariffDefinitionPort.findCustomerTariffDefinitionListByIdList(idList);
    }

    private List<CustomerTariffDefinitionDTO> prepareCustomerTariffDefinitionDTOForNoAction(List<CustomerTariffDefinitionDTO> customerTariffDefinitionDTOList){
        List<CustomerTariffDefinitionDTO> updatedCustomerTariffDefinitionDTOList = new ArrayList<>();
        for(CustomerTariffDefinitionDTO customerTariffDefinitionDTO: customerTariffDefinitionDTOList){
            customerTariffDefinitionDTO.setSourceApplication(SCREEN_NAME);
            customerTariffDefinitionDTO.setStartDate(LocalDate.now());
            updatedCustomerTariffDefinitionDTOList.add(customerTariffDefinitionDTO);
        }
        return updatedCustomerTariffDefinitionDTOList;
    }

    private List<CustomerTariffDefinitionDTO> prepareCustomerTariffDefinitionDTOForUpdateBasePriceAction(List<CustomerTariffDefinitionDTO> customerTariffDefinitionDTOList){
        List<CustomerTariffDefinitionDTO> updatedCustomerTariffDefinitionDTOList = new ArrayList<>();
        for(CustomerTariffDefinitionDTO customerTariffDefinitionDTO: customerTariffDefinitionDTOList){
            customerTariffDefinitionDTO.setSourceApplication(SCREEN_NAME);
            customerTariffDefinitionDTO.setStartDate(LocalDate.now());
            customerTariffDefinitionDTO.setType(BASE_PRICE);
            customerTariffDefinitionDTO.setAmount(null);
            customerTariffDefinitionDTO.setMinAmount(null);
            customerTariffDefinitionDTO.setMaxAmount(null);
            customerTariffDefinitionDTO.setMinOperationAmount(null);
            customerTariffDefinitionDTO.setMaxOperationAmount(null);
            customerTariffDefinitionDTO.setChannelCode(null);
            customerTariffDefinitionDTO.setRate(null);
            updatedCustomerTariffDefinitionDTOList.add(customerTariffDefinitionDTO);
        }
        return updatedCustomerTariffDefinitionDTOList;
    }
}
package com.ykb.corebanking.commission.batch.jobs.ctr.steps.cancelapproval;

import com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchException;
import com.ykb.corebanking.commission.domain.constants.CustomerTariffDefinitionApprovalConstants;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustTariffDefApprovalDetDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffApvlMessageDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefApprovalDTO;
import com.ykb.corebanking.commission.domain.enums.CustomerTariffDefinitionDetailStatus;
import com.ykb.corebanking.commission.domain.enums.CustomerTariffDefinitionOperations;
import com.ykb.corebanking.commission.domain.enums.CustomerTariffDefinitionStatus;
import com.ykb.corebanking.commission.domain.enums.CustomerTariffDefinitionStatusDetail;
import com.ykb.corebanking.commission.domain.port.FlowxRestPort;
import com.ykb.corebanking.commission.domain.port.customertariffdefinition.CustomerTariffDefinitionApprovalPort;
import com.ykb.corebanking.commission.infrastructure.common.mapper.dto.customertariffdefinition.CustomerTariffApvlMessageDTOMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Date;
import java.util.List;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchMessages.CANCEL_TARIFF_DEFINITION_MESSAGE;
import static com.ykb.corebanking.commission.domain.constants.CustomerTariffDefinitionConstants.USER_SYSTEM;

@Slf4j
public class CtrCancelApprovalWriter implements ItemWriter<CustomerTariffDefApprovalDTO> {

    @Autowired
    private CustomerTariffDefinitionApprovalPort customerTariffDefinitionApprovalPort;

    @Autowired
    private FlowxRestPort flowxRestPort;

    @Override
    public void write(Chunk<? extends CustomerTariffDefApprovalDTO> masterDtoList) throws Exception {

        for(CustomerTariffDefApprovalDTO masterDTO : masterDtoList){

            List<CustTariffDefApprovalDetDTO> detailDTOList = customerTariffDefinitionApprovalPort.getCustomerTariffDefinitionApprovalDetailByMasterId(masterDTO.getId());

            masterDTO.setLastUpdatedBy(USER_SYSTEM);
            masterDTO.setLastUpdateDate(new Date());
            masterDTO.setStatusCode(CustomerTariffDefinitionStatus.CANCELED.getKey());
            masterDTO.setStatusDetail(CustomerTariffDefinitionStatusDetail.COMPLETED.getKey());
            detailDTOList.forEach(i -> i.setStatusCode(CustomerTariffDefinitionDetailStatus.CANCELED.getKey()));

            CustomerTariffApvlMessageDTO messageDTO = CustomerTariffApvlMessageDTOMapper.mapperInstance
                    .buildMessageDTO(USER_SYSTEM, USER_SYSTEM, masterDTO.getStatusCode(), CANCEL_TARIFF_DEFINITION_MESSAGE, masterDTO.getId());

            customerTariffDefinitionApprovalPort.saveMaster(masterDTO, USER_SYSTEM, CustomerTariffDefinitionOperations.UPD.getKey());
            customerTariffDefinitionApprovalPort.saveMessage(messageDTO);

            if(!detailDTOList.isEmpty()){
                customerTariffDefinitionApprovalPort.saveDetail(detailDTOList, USER_SYSTEM, CustomerTariffDefinitionOperations.UPD.getKey());
            }

            try {
                flowxRestPort.cancel(masterDTO.getUniqueProcessId().toString(), CustomerTariffDefinitionApprovalConstants.PROCESS_TYPE_CODE, USER_SYSTEM );
            } catch (Exception e){
                log.info("Couldn't cancelled process. Reference ID: %d", masterDTO.getUniqueProcessId());
                throw new CtrBatchException(String.format("Couldn't cancelled process. Reference ID: %d", masterDTO.getUniqueProcessId()));
            }

        }
    }
}


package com.ykb.corebanking.commission.batch.jobs.ctr.steps.notification;

import com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchException;
import com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchExceptionMessages;
import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.client.notificationservice.DestinationDTO;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.notification.NotificationServiceInputDto;
import com.ykb.corebanking.commission.domain.data.notification.NotificationServiceOutputDto;
import com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction;
import com.ykb.corebanking.commission.domain.port.NotificationServicePort;
import com.ykb.corebanking.commission.domain.port.ctr.CtrPort;
import com.ykb.corebanking.commission.domain.util.ControlUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.time.DateUtils;
import org.apache.curator.shaded.com.google.common.collect.Lists;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;

import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.*;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_PROCESS_DEFINITION_DTO;

@Slf4j
public class CtrNotificationTasklet implements Tasklet {

    @Autowired
    private CustomJobParameters<String, Object> customJobParameters;

    @Autowired
    private CtrPort ctrPort;

    @Autowired
    private NotificationServicePort notificationServicePort;

    @Autowired
    @Value("${ctr.notificationPartitionSize:5}")
    private Integer notificationPartitionSize;

    @Override
    public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws CtrBatchException {
        CtrProcessDefinitionDTO ctrProcessDefinitionDTO = (CtrProcessDefinitionDTO)customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO);
        List<String> branchList = ctrPort.getAllBranchesOfSuccessOperationsByActionAndProcessId(Arrays.asList(CtrBatchTariffDefinitionAction.DELETE.getKey(),
                        CtrBatchTariffDefinitionAction.UPDATE_BASEPRICE.getKey()),ctrProcessDefinitionDTO.getId());

        log.info("Notification partition size: {}", notificationPartitionSize);

        boolean hasFailedCall = false;

        if(!ControlUtil.isEmpty(branchList)){
            for(List<String> branchesToSendNotification : Lists.partition(branchList, notificationPartitionSize)){
                hasFailedCall = callNotificationService(branchesToSendNotification, ctrProcessDefinitionDTO);
            }
        }else{
            log.info("No operation found to send notification for it!");
        }

        if(hasFailedCall){
            throw new CtrBatchException(CtrBatchExceptionMessages.NOTIFICATION_SERVICE_FAILED);
        }
        return RepeatStatus.FINISHED;
    }

    private boolean callNotificationService(List<String> branchesToSendNotification, CtrProcessDefinitionDTO ctrProcessDefinitionDTO) {
        log.info("Calling notification service for branch: {}", String.join(", ", branchesToSendNotification));
        NotificationServiceInputDto inputDto = getFilledNotificationInput(branchesToSendNotification, ctrProcessDefinitionDTO.
                getOperationDate().format(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT)));
        NotificationServiceOutputDto notificationServiceOutputDto = notificationServicePort.callWithJaxWs(inputDto);
        log.info("Notification DTO: {}", Objects.toString(notificationServiceOutputDto, "Has no value"));
        if(isServiceFailed(notificationServiceOutputDto)){
            log.info("Notification service failed. Trying again...");
            notificationServiceOutputDto = notificationServicePort.callWithJaxWs(inputDto);
            log.info("Notification DTO: {}", Objects.toString(notificationServiceOutputDto, "Has no value"));
            if(isServiceFailed(notificationServiceOutputDto)){
                log.info("Notification service failed for branch: {}", String.join(", ", branchesToSendNotification));
                return true;
            }
            log.info("Notification called successfully.");
        }
        return false;
    }

    private boolean isServiceFailed(NotificationServiceOutputDto notificationServiceOutputDto){
        return notificationServiceOutputDto == null || !"SUCCESS".equalsIgnoreCase(notificationServiceOutputDto.getResponseDesc());
    }

    private NotificationServiceInputDto getFilledNotificationInput(List<String> branchList, String operationDate) {

        List<DestinationDTO> destinationDTOS = branchList.stream().map(branch -> {
            DestinationDTO destinationDTO = new DestinationDTO();
            destinationDTO.setBranchId(branch);
            destinationDTO.setChannelProfileRole("MS_SB_SAT"); //Şube Satış Ekipleri
            return destinationDTO;
        }).toList();

        NotificationServiceInputDto notificationData = new NotificationServiceInputDto();
        notificationData.setAction("add");
        notificationData.setLabel("");
        notificationData.setNotificationType(1);
        notificationData.setUserId("SYSTEM-GEN");
        notificationData.setBypassMaxNumberOfTabs(5);
        notificationData.setNotificationDate(new Date());
        notificationData.setPriority(100);
        notificationData.setUrl("");
        notificationData.setProcessId(78002L); // Raporlama Merkezi
        notificationData.setTemplateSubTypeCode("MGG_OPERASYON_RAPORU");
        notificationData.setTemplateVariableMap(Map.of("operationDate", operationDate));
        notificationData.setTaskInstanceId(String.valueOf(UUID.randomUUID().getLeastSignificantBits()));
        notificationData.setDestinations(destinationDTOS);
        notificationData.setExpireDate(DateUtils.addDays(new Date(), 10));

        return notificationData;
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation;

import com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchException;
import com.ykb.corebanking.commission.batch.utils.CtrJobUtil;
import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.domain.data.ctr.*;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDetailDTO;
import com.ykb.corebanking.commission.domain.data.customerdeserve.CustomerDeserveInputDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefinitionDTO;
import com.ykb.corebanking.commission.domain.domainmodel.customerdeserve.CustomerDeserveDomainModel;
import com.ykb.corebanking.commission.domain.enums.CtrBatchOperationStatus;
import com.ykb.corebanking.commission.domain.enums.CtrLimitControlFlag;
import com.ykb.corebanking.commission.domain.port.CustomerDeservePort;
import com.ykb.corebanking.commission.domain.port.ctr.CtrPort;
import com.ykb.corebanking.commission.domain.port.customertariffdefinition.CustomerTariffDefinitionPort;
import com.ykb.corebanking.commission.domain.util.CommonUtil;
import com.ykb.corebanking.commission.domain.util.ControlUtil;
import com.ykb.corebanking.commission.domain.util.CustomerTariffReviewUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.curator.shaded.com.google.common.collect.Lists;
import org.jetbrains.annotations.NotNull;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ConcurrentMap;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_CURRENCY_CONVERT;
import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_PROCESS_DEFINITION_DTO;
import static com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchExceptionMessages.NO_RULE_FOR_SBU_TYPE_MESSAGE;
import static com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction.SEND_REVIEW_EXPIRE;
import static com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction.SEND_REVIEW_EXPIRE_DEL;

@Slf4j
public class CtrNormalPreparationProcessor implements ItemProcessor<CtrClientPortfolioDTO, CtrOperationResultDTO> {

    @Autowired
    private CustomerTariffDefinitionPort customerTariffDefinitionPort;

    @Autowired
    private CtrPort ctrPort;

    @Autowired
    private CustomerDeservePort customerDeservePort;

    @Autowired
    private CustomJobParameters<String, Object> customJobParameters;

    @Override
    public CtrOperationResultDTO process(@NotNull CtrClientPortfolioDTO client) throws Exception {

        try {
            if (CustomerTariffReviewUtil.isSbuMismatch(client.getPortfolioSbuType(), client.getSbuType(), customerDeservePort.getCustomerDeserveTypeParameter())) {
                log.info("Detected sbu mismatch (Client No: {}, Client Sbu Type: {}, Client Portfolio Sbu Type: {}). Skipping...",
                        client.getClientNo(), client.getSbuType(), client.getPortfolioSbuType());
                return null;
            }

            CtrProcessDefinitionDTO ctrProcessDefinitionDTO = ((CtrProcessDefinitionDTO) customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO));

            ConcurrentMap<String, BigDecimal> tellerRatesList = (ConcurrentMap<String, BigDecimal>) customJobParameters.getByKey(CTR_CURRENCY_CONVERT);

            CtrProcessDefinitionDetailDTO ctrProcessDefinitionDetailDTO =
                    ctrPort.getSbuListOfWaitingProcessDefinition(ctrProcessDefinitionDTO.getId()).get(client.getSbuType());

            List<String> operationCodes = ctrPort.getOperationCodesForProcessDetailByProcessDefinitionId(ctrProcessDefinitionDTO.getId(), client.getSbuType());

            BigDecimal tariffDefinitionAmount = CtrJobUtil.getTariffDefinitionAmount(ctrProcessDefinitionDetailDTO);

            //get client's active tariff definitions
            List<CustomerTariffDefinitionDTO> customerTariffDefinitionDTOS = new ArrayList<>();

            if (operationCodes.isEmpty()) {
                customerTariffDefinitionDTOS.addAll(ctrPort.getClientActiveTariffDefinitionList(client.getClientNo(),
                        ctrProcessDefinitionDetailDTO.getExemptionDateControlPeriod(),
                        operationCodes,
                        tariffDefinitionAmount));
            }

            for (List<String> partitionedOperations : Lists.partition(operationCodes, 998)) {
                customerTariffDefinitionDTOS.addAll(ctrPort.getClientActiveTariffDefinitionList(client.getClientNo(),
                        ctrProcessDefinitionDetailDTO.getExemptionDateControlPeriod(),
                        partitionedOperations,
                        tariffDefinitionAmount));
            }

            if (ControlUtil.isEmpty(customerTariffDefinitionDTOS)) return null;

            CtrOperationResultDTO ctrOperationResultDTO = new CtrOperationResultDTO();

            Long ctrOperationResultId = ctrPort.getCtrOperationResultSequenceNextValue();

            //get deserveFlag
            String deserveType = CtrJobUtil.getDeserveType(CustomerDeserveDomainModel.getInstance(customerDeservePort)
                    .getInformation(new CustomerDeserveInputDTO(client.getClientNo(), client.getPortfolioSbuType())));

            Integer undeservedArrivalCount = null;

            if (CustomerTariffReviewUtil.isDeserveTypeUndeserved(deserveType)) {
                undeservedArrivalCount = CustomerTariffReviewUtil
                        .countUndeservedArrival(ctrPort.getLastTwoCtrOperationResultDtoOfClient(client.getClientNo()));
            }

            Long processCount = ctrPort.countOperationRecordsByClientNo(client.getClientNo());

            ctrOperationResultDTO.setCtrProcessDefinitionId(ctrProcessDefinitionDTO.getId());
            ctrOperationResultDTO.setOperationDate(ctrProcessDefinitionDTO.getOperationDate());
            ctrOperationResultDTO.setSbuType(ctrProcessDefinitionDetailDTO.getSbuType());
            ctrOperationResultDTO.setClientNo(client.getClientNo());
            ctrOperationResultDTO.setCustomerDeserveType(deserveType);
            ctrOperationResultDTO.setUndeservedArrivalCount(undeservedArrivalCount);
            ctrOperationResultDTO.setProcessCount(processCount + 1);
            ctrOperationResultDTO.setExemptionType(ctrProcessDefinitionDetailDTO.getExemptionType());
            ctrOperationResultDTO.setBranchCode(client.getClientBranchCode());
            ctrOperationResultDTO.setPortfolioCode(client.getPortfolioCode());
            ctrOperationResultDTO.setPortfolioSbuType(client.getPortfolioSbuType());
            ctrOperationResultDTO.setPortfolioBranchCode(client.getPortfolioBranchCode());
            ctrOperationResultDTO.setId(ctrOperationResultId);

            for (CustomerTariffDefinitionDTO tariffDefinition : customerTariffDefinitionDTOS) {

                CtrOperationResultDetailDTO ctrOperationResultDetailDTO = new CtrOperationResultDetailDTO();


                //limit control
                CtrLimitDefinitionDTO ctrLimitDefinitionDTO = CtrJobUtil.getMatchedLimitDefinition(
                        tariffDefinition.getOperationCode(), ctrProcessDefinitionDetailDTO.getSbuType(),
                        tariffDefinition.getChannelCode(), CommonUtil.toTL(tariffDefinition.getCurrency()),
                        ctrPort.getAllLimitDefinitions()
                );

                CtrMinLimitDTO ctrMinLimitDTO = CtrJobUtil.getMinLimitInformation(ctrProcessDefinitionDetailDTO, ctrLimitDefinitionDTO,
                        tariffDefinition, tellerRatesList, ctrPort.getBasePriceDefinition());
                String limitControlStatus = CtrJobUtil.getLimitControlStatus(tariffDefinition, ctrMinLimitDTO.getMinLimit(), ctrMinLimitDTO.getMinLimitCurrency(), tellerRatesList);

                CtrRuleDefinitionDTO ruleDefinitionDTO = CtrJobUtil.getMatchedRuleDefinition(ctrProcessDefinitionDetailDTO.getSbuType(),
                        ctrOperationResultDTO.getCustomerDeserveType(), ctrOperationResultDTO.getUndeservedArrivalCount(),
                        limitControlStatus, ctrPort.getAllRuleDefinitions());

                if (Objects.isNull(ruleDefinitionDTO)) {
                    log.error("Couldn't find any rule definition (portfolio sbu type: {}, deserve type: {}, undeserved arrival count: {}, client no: {}, client sbu type: {})",
                            client.getPortfolioSbuType(), ctrOperationResultDTO.getCustomerDeserveType(),
                            ctrOperationResultDTO.getUndeservedArrivalCount(), client.getClientNo(), client.getSbuType());
                    throw new CtrBatchException(String.format(NO_RULE_FOR_SBU_TYPE_MESSAGE, client.getPortfolioSbuType(), ctrOperationResultDTO.getCustomerDeserveType(),
                            ctrOperationResultDTO.getUndeservedArrivalCount(), client.getClientNo(), client.getSbuType()));
                }

                ctrOperationResultDetailDTO.setRuleId(ruleDefinitionDTO.getId());
                ctrOperationResultDetailDTO.setAction(ruleDefinitionDTO.getAction());
                ctrOperationResultDetailDTO.setLimitControlStatus(limitControlStatus);
                ctrOperationResultDetailDTO.setLimitControlFlag(ruleDefinitionDTO.getLimitControlStatus().equals(limitControlStatus) ? CtrLimitControlFlag.YES.getKey() : CtrLimitControlFlag.NO.getKey());
                ctrOperationResultDetailDTO.setMinLimit(ctrMinLimitDTO.getMinLimit());
                ctrOperationResultDetailDTO.setMinLimitCurrency(ctrMinLimitDTO.getMinLimitCurrency());
                ctrOperationResultDetailDTO.setCurrency(tariffDefinition.getCurrency());
                ctrOperationResultDetailDTO.setCustomerTariffDefinitonId(tariffDefinition.getId());
                ctrOperationResultDetailDTO.setOperationCode(tariffDefinition.getOperationCode());
                ctrOperationResultDetailDTO.setAmount(tariffDefinition.getAmount());
                ctrOperationResultDetailDTO.setRate(tariffDefinition.getRate());
                ctrOperationResultDetailDTO.setMinAmount(tariffDefinition.getMinAmount());
                ctrOperationResultDetailDTO.setMaxAmount(tariffDefinition.getMaxAmount());
                ctrOperationResultDetailDTO.setMinOperationAmount(tariffDefinition.getMinOperationAmount());
                ctrOperationResultDetailDTO.setMaxOperationAmount(tariffDefinition.getMaxOperationAmount());
                ctrOperationResultDetailDTO.setChannelCode(tariffDefinition.getChannelCode());
                ctrOperationResultDetailDTO.setDirection(tariffDefinition.getDirection());
                ctrOperationResultDetailDTO.setAccountNo(tariffDefinition.getAccountNo());
                ctrOperationResultDetailDTO.setAccountCurrency(tariffDefinition.getAccountCurrency());
                ctrOperationResultDetailDTO.setStartDate(tariffDefinition.getStartDate());
                ctrOperationResultDetailDTO.setEndDate(tariffDefinition.getEndDate());
                ctrOperationResultDetailDTO.setFeeId(tariffDefinition.getFeeId());
                ctrOperationResultDetailDTO.setDemandReason(tariffDefinition.getDemandReason());
                ctrOperationResultDetailDTO.setCreatedBy(tariffDefinition.getCreatedBy());
                ctrOperationResultDetailDTO.setBlockType(ruleDefinitionDTO.getBlockType());
                ctrOperationResultDetailDTO.setBlockTimePeriod(ruleDefinitionDTO.getBlockTimePeriod());
                ctrOperationResultDetailDTO.setType(tariffDefinition.getType());
                ctrOperationResultDetailDTO.setStatus(CtrBatchOperationStatus.WAITING_ACTION.getKey());
                ctrOperationResultDetailDTO.setLastReviewDate(calculateLastReviewDate(ruleDefinitionDTO.getAction(),
                        ctrProcessDefinitionDetailDTO.getExpirePeriod(), ctrProcessDefinitionDTO.getOperationDate()));
                ctrOperationResultDetailDTO.setCtrOperationResultId(ctrOperationResultId);
                // limited exemption
                ctrOperationResultDetailDTO.setCount(tariffDefinition.getCount());
                ctrOperationResultDetailDTO.setDuration(tariffDefinition.getDuration());
                ctrOperationResultDTO.getCtrOperationResultDetailDTOS().add(ctrOperationResultDetailDTO);
            }

            return ctrOperationResultDTO;
        } catch (Exception exception) {
            log.error("Item --> {}", client);
            throw exception;
        }
    }

    private LocalDate calculateLastReviewDate(String action, Integer expirePeriod, LocalDate operationDate) {
        return (SEND_REVIEW_EXPIRE_DEL.getKey().equals(action)
                || SEND_REVIEW_EXPIRE.getKey().equals(action)) ?
                operationDate.plusDays(Math.max(0, expirePeriod - 1)) :
                null;
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation;

import com.ykb.corebanking.commission.domain.data.ctr.CtrOperationResultDTO;
import com.ykb.corebanking.commission.domain.data.ctr.CtrOperationResultDetailDTO;
import com.ykb.corebanking.commission.infrastructure.common.util.SqlUtils;
import jakarta.annotation.PostConstruct;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.sql.DataSource;

public class CtrNormalPreparationWriter implements ItemWriter<CtrOperationResultDTO> {

    private JdbcBatchItemWriter<CtrOperationResultDTO> ctrOperationResultDTOJdbcBatchItemWriter;
    private JdbcBatchItemWriter<CtrOperationResultDetailDTO> ctrOperationResultDetailDTOJdbcBatchItemWriter;

    @Value("classpath:sql/customertariffreview/insertCtrOperationResult.sql")
    private Resource insertCtrOperationResultSqlResource;

    @Value("classpath:sql/customertariffreview/insertCtrOperationDetailResult.sql")
    private Resource insertCtrOperationDetailResultSqlResource;

    @Autowired
    @Qualifier("commissionDatasource")
    private DataSource commissionDatasource;

    @PostConstruct
    public void afterPropertiesSet() {
        final String ctrOperationResultDTOInsertSql = SqlUtils.readSql(insertCtrOperationResultSqlResource);
        final String ctrOperationResultDetailDTOInsertSql = SqlUtils.readSql(insertCtrOperationDetailResultSqlResource);

        ctrOperationResultDTOJdbcBatchItemWriter = new JdbcBatchItemWriter<>();
        ctrOperationResultDTOJdbcBatchItemWriter.setSql(ctrOperationResultDTOInsertSql);
        ctrOperationResultDTOJdbcBatchItemWriter.setDataSource(commissionDatasource);
        ctrOperationResultDTOJdbcBatchItemWriter.setJdbcTemplate(new NamedParameterJdbcTemplate(commissionDatasource));
        ctrOperationResultDTOJdbcBatchItemWriter.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
        ctrOperationResultDTOJdbcBatchItemWriter.afterPropertiesSet();


        ctrOperationResultDetailDTOJdbcBatchItemWriter = new JdbcBatchItemWriter<>();
        ctrOperationResultDetailDTOJdbcBatchItemWriter.setSql(ctrOperationResultDetailDTOInsertSql);
        ctrOperationResultDetailDTOJdbcBatchItemWriter.setDataSource(commissionDatasource);
        ctrOperationResultDetailDTOJdbcBatchItemWriter.setJdbcTemplate(new NamedParameterJdbcTemplate(commissionDatasource));
        ctrOperationResultDetailDTOJdbcBatchItemWriter.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
        ctrOperationResultDetailDTOJdbcBatchItemWriter.afterPropertiesSet();
    }

    @Override
    public void write(Chunk<? extends CtrOperationResultDTO> ctrOperationResultList) throws Exception {

        ctrOperationResultDTOJdbcBatchItemWriter.write(ctrOperationResultList);

        ctrOperationResultDetailDTOJdbcBatchItemWriter.write(new Chunk<>(ctrOperationResultList.getItems().stream()
                .flatMap(i -> i.getCtrOperationResultDetailDTOS().stream()).toList()));
    }
}


package com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation;

import com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchException;
import com.ykb.corebanking.commission.batch.utils.CtrJobUtil;
import com.ykb.corebanking.commission.batch.utils.CustomJobParameters;
import com.ykb.corebanking.commission.domain.data.ctr.*;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDetailDTO;
import com.ykb.corebanking.commission.domain.data.customerdeserve.CustomerDeserveInputDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefinitionDTO;
import com.ykb.corebanking.commission.domain.domainmodel.customerdeserve.CustomerDeserveDomainModel;
import com.ykb.corebanking.commission.domain.enums.CtrLimitControlFlag;
import com.ykb.corebanking.commission.domain.port.CustomerDeservePort;
import com.ykb.corebanking.commission.domain.port.ctr.CtrPort;
import com.ykb.corebanking.commission.domain.port.customertariffdefinition.CustomerTariffDefinitionPort;
import com.ykb.corebanking.commission.domain.util.CommonUtil;
import com.ykb.corebanking.commission.domain.util.ControlUtil;
import com.ykb.corebanking.commission.domain.util.CustomerTariffReviewUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.curator.shaded.com.google.common.collect.Lists;
import org.jetbrains.annotations.NotNull;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ConcurrentMap;

import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_CURRENCY_CONVERT;
import static com.ykb.corebanking.commission.batch.jobs.ctr.base.CtrBatchConstants.CTR_PROCESS_DEFINITION_DTO;
import static com.ykb.corebanking.commission.batch.jobs.ctr.exception.CtrBatchExceptionMessages.NO_RULE_FOR_SBU_TYPE_MESSAGE;
import static com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction.SEND_REVIEW_EXPIRE;
import static com.ykb.corebanking.commission.domain.enums.CtrBatchTariffDefinitionAction.SEND_REVIEW_EXPIRE_DEL;

@Slf4j
public class CtrSimulationPreparationProcessor implements ItemProcessor<CtrClientPortfolioDTO, List<CtrSimulationResultDTO>> {

    @Autowired
    private CustomerTariffDefinitionPort customerTariffDefinitionPort;

    @Autowired
    private CtrPort ctrPort;

    @Autowired
    private CustomJobParameters<String, Object> customJobParameters;

    @Autowired
    private CustomerDeservePort customerDeservePort;

    @Override
    public List<CtrSimulationResultDTO> process(@NotNull CtrClientPortfolioDTO client) throws Exception {

        try {
            if (CustomerTariffReviewUtil.isSbuMismatch(client.getPortfolioSbuType(), client.getSbuType(), customerDeservePort.getCustomerDeserveTypeParameter())) {
                log.info("Detected sbu mismatch (Client No: {}, Client Sbu Type: {}, Client Portfolio Sbu Type: {}). Skipping...",
                        client.getClientNo(), client.getSbuType(), client.getPortfolioSbuType());
                return null;
            }

            Long ctrProcessDefinitionId = ((CtrProcessDefinitionDTO) customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO)).getId();

            ConcurrentMap<String, BigDecimal> tellerRatesList = (ConcurrentMap<String, BigDecimal>) customJobParameters.getByKey(CTR_CURRENCY_CONVERT);

            CtrProcessDefinitionDetailDTO ctrProcessDefinitionDetailDTO =
                    ctrPort.getSbuListOfWaitingProcessDefinition(ctrProcessDefinitionId).get(client.getSbuType());

            List<String> operationCodes = ctrPort.getOperationCodesForProcessDetailByProcessDefinitionId(ctrProcessDefinitionId, client.getSbuType());

            BigDecimal tariffDefinitionAmount = CtrJobUtil.getTariffDefinitionAmount(ctrProcessDefinitionDetailDTO);

            List<CtrSimulationResultDTO> ctrSimulationResultDTOS = new ArrayList<>();

            //get client's active tariff definitions
            List<CustomerTariffDefinitionDTO> customerTariffDefinitionDTOS = new ArrayList<>();

            if (operationCodes.isEmpty()) {
                customerTariffDefinitionDTOS.addAll(ctrPort.getClientActiveTariffDefinitionList(client.getClientNo(),
                        ctrProcessDefinitionDetailDTO.getExemptionDateControlPeriod(),
                        operationCodes,
                        tariffDefinitionAmount));
            }

            for (List<String> partitionedOperations : Lists.partition(operationCodes, 998)) {
                customerTariffDefinitionDTOS.addAll(ctrPort.getClientActiveTariffDefinitionList(client.getClientNo(),
                        ctrProcessDefinitionDetailDTO.getExemptionDateControlPeriod(),
                        partitionedOperations,
                        tariffDefinitionAmount));
            }

            if (ControlUtil.isEmpty(customerTariffDefinitionDTOS)) return null;

            //get deserveFlag
            String deserveType = CtrJobUtil.getDeserveType(CustomerDeserveDomainModel.getInstance(customerDeservePort)
                    .getInformation(new CustomerDeserveInputDTO(client.getClientNo(), client.getPortfolioSbuType())));

            Integer undeservedArrivalCount = null;

            if (CustomerTariffReviewUtil.isDeserveTypeUndeserved(deserveType)) {
                undeservedArrivalCount = CustomerTariffReviewUtil
                        .countUndeservedArrival(ctrPort.getLastTwoCtrOperationResultDtoOfClient(client.getClientNo()));
            }

            Long processCount = ctrPort.countOperationRecordsByClientNo(client.getClientNo());

            for (CustomerTariffDefinitionDTO tariffDefinition : customerTariffDefinitionDTOS) {

                CtrSimulationResultDTO ctrSimulationResultDTO = new CtrSimulationResultDTO();
                ctrSimulationResultDTO.setCtrProcessDefinitionId(ctrProcessDefinitionId);
                ctrSimulationResultDTO.setOperationDate(((CtrProcessDefinitionDTO) customJobParameters.getByKey(CTR_PROCESS_DEFINITION_DTO)).getOperationDate());
                ctrSimulationResultDTO.setSbuType(ctrProcessDefinitionDetailDTO.getSbuType());
                ctrSimulationResultDTO.setClientNo(client.getClientNo());
                ctrSimulationResultDTO.setCustomerDeserveType(deserveType);
                ctrSimulationResultDTO.setUndeservedArrivalCount(undeservedArrivalCount);
                ctrSimulationResultDTO.setProcessCount(processCount + 1);
                ctrSimulationResultDTO.setExemptionType(ctrProcessDefinitionDetailDTO.getExemptionType());
                ctrSimulationResultDTO.setBranchCode(client.getClientBranchCode());
                ctrSimulationResultDTO.setPortfolioCode(client.getPortfolioCode());
                ctrSimulationResultDTO.setPortfolioSbuType(client.getPortfolioSbuType());
                ctrSimulationResultDTO.setPortfolioBranchCode(client.getPortfolioBranchCode());

                //limit control
                CtrLimitDefinitionDTO ctrLimitDefinitionDTO = CtrJobUtil.getMatchedLimitDefinition(
                        tariffDefinition.getOperationCode(), ctrProcessDefinitionDetailDTO.getSbuType(),
                        tariffDefinition.getChannelCode(), CommonUtil.toTL(tariffDefinition.getCurrency()),
                        ctrPort.getAllLimitDefinitions()
                );

                CtrMinLimitDTO ctrMinLimitDTO = CtrJobUtil.getMinLimitInformation(ctrProcessDefinitionDetailDTO, ctrLimitDefinitionDTO,
                        tariffDefinition, tellerRatesList, ctrPort.getBasePriceDefinition());
                String limitControlStatus = CtrJobUtil.getLimitControlStatus(tariffDefinition, ctrMinLimitDTO.getMinLimit(), ctrMinLimitDTO.getMinLimitCurrency(), tellerRatesList);

                CtrRuleDefinitionDTO ruleDefinitionDTO = CtrJobUtil.getMatchedRuleDefinition(ctrProcessDefinitionDetailDTO.getSbuType(),
                        ctrSimulationResultDTO.getCustomerDeserveType(), ctrSimulationResultDTO.getUndeservedArrivalCount(),
                        limitControlStatus, ctrPort.getAllRuleDefinitions());

                if (Objects.isNull(ruleDefinitionDTO)) {
                    log.error("Couldn't find any rule definition (portfolio sbu type: {}, deserve type: {}, undeserved arrival count: {}, client no: {}, client sbu type: {})",
                            client.getPortfolioSbuType(), ctrSimulationResultDTO.getCustomerDeserveType(),
                            ctrSimulationResultDTO.getUndeservedArrivalCount(), client.getClientNo(), client.getSbuType());
                    throw new CtrBatchException(String.format(NO_RULE_FOR_SBU_TYPE_MESSAGE, client.getPortfolioSbuType(), ctrSimulationResultDTO.getCustomerDeserveType(),
                            ctrSimulationResultDTO.getUndeservedArrivalCount(), client.getClientNo(), client.getSbuType()));
                }

                ctrSimulationResultDTO.setRuleId(ruleDefinitionDTO.getId());
                ctrSimulationResultDTO.setAction(ruleDefinitionDTO.getAction());
                ctrSimulationResultDTO.setLimitControlStatus(limitControlStatus);
                ctrSimulationResultDTO.setLimitControlFlag(ruleDefinitionDTO.getLimitControlStatus().equals(limitControlStatus) ? CtrLimitControlFlag.YES.getKey() : CtrLimitControlFlag.NO.getKey());
                ctrSimulationResultDTO.setMinLimit(ctrMinLimitDTO.getMinLimit());
                ctrSimulationResultDTO.setMinLimitCurrency(ctrMinLimitDTO.getMinLimitCurrency());
                ctrSimulationResultDTO.setCurrency(tariffDefinition.getCurrency());
                ctrSimulationResultDTO.setCustomerTariffDefinitionId(tariffDefinition.getId());
                ctrSimulationResultDTO.setOperationCode(tariffDefinition.getOperationCode());
                ctrSimulationResultDTO.setAmount(tariffDefinition.getAmount());
                ctrSimulationResultDTO.setRate(tariffDefinition.getRate());
                ctrSimulationResultDTO.setMinAmount(tariffDefinition.getMinAmount());
                ctrSimulationResultDTO.setMaxAmount(tariffDefinition.getMaxAmount());
                ctrSimulationResultDTO.setMinOperationAmount(tariffDefinition.getMinOperationAmount());
                ctrSimulationResultDTO.setMaxOperationAmount(tariffDefinition.getMaxOperationAmount());
                ctrSimulationResultDTO.setChannelCode(tariffDefinition.getChannelCode());
                ctrSimulationResultDTO.setDirection(tariffDefinition.getDirection());
                ctrSimulationResultDTO.setAccountNo(tariffDefinition.getAccountNo());
                ctrSimulationResultDTO.setAccountCurrency(tariffDefinition.getAccountCurrency());
                ctrSimulationResultDTO.setStartDate(tariffDefinition.getStartDate());
                ctrSimulationResultDTO.setEndDate(tariffDefinition.getEndDate());
                ctrSimulationResultDTO.setFeeId(tariffDefinition.getFeeId());
                ctrSimulationResultDTO.setDemandReason(tariffDefinition.getDemandReason());
                ctrSimulationResultDTO.setCreatedBy(tariffDefinition.getCreatedBy());
                ctrSimulationResultDTO.setBlockType(ruleDefinitionDTO.getBlockType());
                ctrSimulationResultDTO.setBlockTimePeriod(ruleDefinitionDTO.getBlockTimePeriod());
                ctrSimulationResultDTO.setType(tariffDefinition.getType());
                ctrSimulationResultDTO.setExpirePeriod((SEND_REVIEW_EXPIRE_DEL.getKey().equals(ruleDefinitionDTO.getAction())
                        || SEND_REVIEW_EXPIRE.getKey().equals(ruleDefinitionDTO.getAction())) ?
                        ctrProcessDefinitionDetailDTO.getExpirePeriod() : null);
                // limited exemption
                ctrSimulationResultDTO.setCount(tariffDefinition.getCount());
                ctrSimulationResultDTO.setDuration(tariffDefinition.getDuration());
                ctrSimulationResultDTOS.add(ctrSimulationResultDTO);
            }
            return ctrSimulationResultDTOS;
        } catch (Exception exception) {
            log.error("Item --> {}", client);
            throw exception;
        }
    }
}

package com.ykb.corebanking.commission.batch.jobs.ctr.steps.preparation;

import com.ykb.corebanking.commission.domain.data.ctr.CtrSimulationResultDTO;
import com.ykb.corebanking.commission.infrastructure.common.util.SqlUtils;
import jakarta.annotation.PostConstruct;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.sql.DataSource;
import java.util.List;

public class CtrSimulationPreparationWriter implements ItemWriter<List<CtrSimulationResultDTO>> {

    private JdbcBatchItemWriter<CtrSimulationResultDTO> ctrSimulationResultDTOJdbcBatchItemWriter;

    @Value("classpath:sql/customertariffreview/insertCtrSimulationResult.sql")
    private Resource insertCtrSimulationResultSqlResource;

    @Autowired
    @Qualifier("commissionDatasource")
    private DataSource commissionDatasource;

    @PostConstruct
    public void afterPropertiesSet() {
        final String ctrSimulationResultDTOInsertSql = SqlUtils.readSql(insertCtrSimulationResultSqlResource);

        ctrSimulationResultDTOJdbcBatchItemWriter = new JdbcBatchItemWriter<>();
        ctrSimulationResultDTOJdbcBatchItemWriter.setSql(ctrSimulationResultDTOInsertSql);
        ctrSimulationResultDTOJdbcBatchItemWriter.setDataSource(commissionDatasource);
        ctrSimulationResultDTOJdbcBatchItemWriter.setJdbcTemplate(new NamedParameterJdbcTemplate(commissionDatasource));
        ctrSimulationResultDTOJdbcBatchItemWriter.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
        ctrSimulationResultDTOJdbcBatchItemWriter.afterPropertiesSet();
    }

    @Override
    public void write(Chunk<? extends List<CtrSimulationResultDTO>> ctrSimulationResultDTOs) throws Exception {
        ctrSimulationResultDTOJdbcBatchItemWriter.write(new Chunk<>(ctrSimulationResultDTOs.getItems().stream()
                .flatMap(List::stream).toList()));
    }
}

package com.ykb.corebanking.commission.domain.port.ctr;

import com.ykb.corebanking.commission.domain.data.basepricedefinition.BasePriceDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctr.*;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDTO;
import com.ykb.corebanking.commission.domain.data.ctrprocessdefinition.CtrProcessDefinitionDetailDTO;
import com.ykb.corebanking.commission.domain.data.customertariffdefinition.CustomerTariffDefinitionDTO;
import org.springframework.cache.annotation.Cacheable;

import java.math.BigDecimal;
import java.util.Date;
import java.util.List;
import java.util.Map;

public interface CtrPort {

    List<CtrOperationResultDTO> getLastTwoCtrOperationResultDtoOfClient(Long clientNo);

    List<BasePriceDefinitionDTO> getBasePriceDefinitionBySbuTypeAndOperationCode(String sbuType, String operationCode, String channelCode, Map<String, String> channelMap);

    List<BasePriceDefinitionDTO> getBasePriceDefinitionByOperationCodeListAndSbuType(List<String> operationCodeList, String sbuType);

    Long countOperationRecordsByClientNo(Long clientNo);

    CtrProcessDefinitionDTO getProcessableDefinitionByWorkingType(String operationModeName);

    @Cacheable(value = "customerTariffReview_CTRBatch_getProcessDefinitionDetails#processDefinitionId", sync = true)
    Map<String, CtrProcessDefinitionDetailDTO> getSbuListOfWaitingProcessDefinition(Long processDefinitionId);

    @Cacheable(value = "customerTariffReview_CTRBatch_getOperationCodesForProcessDetailByProcessDefinitionDetailId#sbuType", sync = true)
    List<String> getOperationCodesForProcessDetailByProcessDefinitionId(Long processDefinitionId, String sbuType);

    List<CustomerTariffDefinitionDTO> getClientActiveTariffDefinitionList(Long clientNo, Integer ctrDate, List<String> operationCodeList, BigDecimal amount);

    void saveOperationResultDetailList(List<CtrOperationResultDetailDTO> ctrOperationResultDetailDTOList);

    Long getCtrOperationResultSequenceNextValue();

    List<String> getRuleDefinitionSbuTypeList();

    List<String> getAllBranchesOfSuccessOperationsByActionAndProcessId(List<String> actionList, Long ctrProcessDefinitionId);

    CtrOperationResultDTO getOperationResultById(Long id);

    List<CtrOperationResultDetailDTO> getOperationResultDetailByStatusAndAction(Long masterId, List<String> actionList, String status);

    List<CtrOperationResultDetailDTO> getOperationResultDetailByIdList(List<Long> idList);

    List<CtrOperationResultDetailDTO> getOperationResultDetailByUniqueProcessId(Long uniqueProcessId);

    List<CtrOperationResultDetailDTO> getOperationResultDetailByUpIdAndCustTariffDefIdList(Long uniqueProcessId, List<Long> customerTariffDefinitionIdList);

    boolean isDetailExistsByStatusAndAction(Long masterId, List<String> actionList, String status);

    List<CtrOperationResultDetailDTO> getOperationResultDetailByUpIdAndStatus(Long uniqueProcessId, String statusList);

    void updateCtrProcessDefinitionStatusByJdbc(Long id, String status);

    List<CtrOperationResultProcessDTO> getDeletedCtrExemptions(Long clientNo, List<String> operationCodeList);

    Date getOperationDateByDetailId(Long id);

    @Cacheable(value = "customerTariffReview_CTRBatch_getAllRuleDefinitions", sync = true)
    Map<String, List<CtrRuleDefinitionDTO>> getAllRuleDefinitions();

    @Cacheable(value = "customerTariffReview_CTRBatch_getAllLimitDefinitions", sync = true)
    Map<String, List<CtrLimitDefinitionDTO>> getAllLimitDefinitions();

    @Cacheable(value = "customerTariffReview_CTRBatch_getBasePriceDefinition", sync = true, key = "#root.methodName")
    Map<String, List<BasePriceDefinitionDTO>> getBasePriceDefinition();

    Integer getExpirePeriodFromCTRProcessDefinitionDetail(String clientSbu, Long ctrOperationResultId);
}
package com.ykb.corebanking.commission.domain.data.basepricedefinition;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class BasePriceDefinitionDTO extends BasePriceDefinitionBaseDTO {
    private Long id;
    private Long feeDefinitionId;
    private String operationType;
}

package com.ykb.corebanking.commission.domain.data.ctr;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@ToString
public class CtrOperationResultDTO {

    public CtrOperationResultDTO() {
        this.ctrOperationResultDetailDTOS = new ArrayList<>();
    }

    private Long id;
    private Long ctrProcessDefinitionId;
    private LocalDate operationDate;
    private String sbuType;
    private Long clientNo;
    private String customerDeserveType;
    private Integer undeservedArrivalCount;
    private Long processCount;
    private String exemptionType;
    private String branchCode;
    private Integer portfolioCode;
    private String portfolioSbuType;
    private String portfolioBranchCode;
    private List<CtrOperationResultDetailDTO> ctrOperationResultDetailDTOS;
}
