package com.ykb.corebanking.commission.batch.base;

public class ApplicationArguments {

    private static String[] arguments;

    ApplicationArguments() {

    }
    public static String[] getArguments() {
        return arguments;
    }

    public static void setArguments(String[] arguments) {
        ApplicationArguments.arguments = arguments;
    }

}

package com.ykb.corebanking.commission.batch.base;

public class BatchConstants {

    BatchConstants() {

    }

    public static final String JOB_PRM_KEY_VALUE_SEPARATOR = "=";

}

package com.ykb.corebanking.commission.batch.base;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.springframework.util.Assert;

@Getter
@Setter
@AllArgsConstructor
public class Tuple<T, K> {

    private final T first;
    private final K second;

    public static Tuple<String, String> build(String[] items) {
        Assert.notNull(items, "'items' can not be null");
        Assert.isTrue(items.length == 2, "'items' must have 2 items in in");
        return new Tuple<>(items[0], items[1]);
    }

}

package com.ykb.corebanking.commission.batch.configuration;

import com.ykb.corebanking.commission.batch.common.CommonJobExecutionListener;
import com.ykb.corebanking.commission.batch.common.CommonStepExecutionListener;
import com.ykb.corebanking.commission.batch.common.ItemFailureLoggerListener;
import com.ykb.corebanking.commission.batch.common.MdcTaskDecorator;
import com.ykb.corebanking.commission.infrastructure.configuration.AccountingChainedTransactionManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.repeat.support.TaskExecutorRepeatTemplate;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Slf4j
public class BaseJobConfiguration implements InitializingBean {

    @Getter
    private DataSource dataSource;

    @Getter
    private CommonJobExecutionListener commonJobExecutionListener;

    @Autowired
    private JobRepository jobRepository;

    @Autowired
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Autowired
    @Qualifier("chainedTransactionManager")
    public AccountingChainedTransactionManager chainedTransactionManager;

    @Autowired
    @Qualifier("transactionManager")
    public PlatformTransactionManager commissionTransactionManager;

    @Autowired
    @Qualifier("cbsliveTransactionManager")
    public PlatformTransactionManager cbsliveTransactionManager;

    @Bean
    @Primary
    public ThreadPoolTaskExecutor processorTaskExecutor() {
        ThreadPoolTaskExecutor asyncTaskExecutorProcess = new ThreadPoolTaskExecutor();
        asyncTaskExecutorProcess.setTaskDecorator(new MdcTaskDecorator());
        return asyncTaskExecutorProcess;
    }

    public TaskExecutorRepeatTemplate repeatTemplate(ThreadPoolTaskExecutor threadPoolTaskExecutor, int throttleLimit){
        TaskExecutorRepeatTemplate repeatTemplate = new TaskExecutorRepeatTemplate();
        repeatTemplate.setTaskExecutor(threadPoolTaskExecutor);
        repeatTemplate.setThrottleLimit(throttleLimit); // NOSONAR
        return repeatTemplate;
    }

    protected JobBuilder getCommonJobBuilderGenericListener(String jobName, JobExecutionListener commonJobExecutionListener) {
        return new JobBuilder(jobName, jobRepository)
                .listener(commonJobExecutionListener);
    }

    protected JobBuilder getCommonJobBuilder(String jobName) {
        return new JobBuilder(jobName, jobRepository)
                .listener(commonJobExecutionListener);
    }

    protected StepBuilder getCommonStepBuilder(String stepName) {
        return new StepBuilder(stepName, jobRepository)
                .listener(new ItemFailureLoggerListener<>())
                .listener(new CommonStepExecutionListener());
    }

    @Override
    public void afterPropertiesSet() {
        log.info("{} is initialized", getClass().getSimpleName());
    }

    @Autowired
    public void setCommonJobExecutionListener(CommonJobExecutionListener commonJobExecutionListener) {
        this.commonJobExecutionListener = commonJobExecutionListener;
    }

}

package com.ykb.corebanking.commission.batch.configuration;

import com.ykb.corebanking.commission.batch.common.CommonJobExecutionListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.config.EnableIntegration;

@Configuration
@EnableIntegration
public class GeneralBatchConfiguration {
    
    @Bean
    public CommonJobExecutionListener commonJobExecutionListener() {
        return new CommonJobExecutionListener();
    }

}

package com.ykb.corebanking.commission.batch.configuration;

import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing(dataSourceRef = "jobRepoDatasource")
public class SpringBatchConfiguration {

    @Bean
    public DataSource jobRepoDatasource() {
        return new EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.H2)
                .setName("job-metadata-db")
                .addScript("classpath:org/springframework/batch/core/schema-drop-h2.sql")
                .addScript("classpath:org/springframework/batch/core/schema-h2.sql")
                .build();
    }
}

package com.ykb.corebanking.commission.batch.util;

import com.ykb.corebanking.commission.batch.base.BatchConstants;
import com.ykb.corebanking.commission.batch.base.Tuple;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.List;
import java.util.Properties;

@Slf4j
public class BatchUtil {

    private BatchUtil() { }

    public static Properties parseJobParameters(String[] args) {
        List<String> jobParameters = Arrays.asList(args);
        Properties props = new Properties();
        jobParameters.forEach(prm -> {
            log.info("Prm to extract: {}", prm);
            Tuple<String, String> keyValue = Tuple
                    .build(prm.split(BatchConstants.JOB_PRM_KEY_VALUE_SEPARATOR));
            log.info("Provided job parameter to be passed, Key:Value => {} : {}",
                    keyValue.getFirst(),
                    keyValue.getSecond());
            props.setProperty(keyValue.getFirst(), keyValue.getSecond());
        });
        return props;
    }

}

package com.ykb.corebanking.commission.batch.common;

import freemarker.cache.ClassTemplateLoader;
import freemarker.cache.FileTemplateLoader;
import freemarker.cache.TemplateLoader;
import freemarker.core.Environment;
import freemarker.template.Configuration;
import freemarker.template.DefaultObjectWrapper;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.Writer;

public class TemplateWriter {

    private final Template template;
    private final Writer writer;

    public TemplateWriter(Resource templateResource, Writer writer) throws IOException {
        this(templateResource,writer,"utf-8");
    }

    public TemplateWriter(Resource templateResource, Writer writer, String defaultEncoding) throws IOException {
        this.writer = writer;

        final Configuration configuration = new Configuration(Configuration.VERSION_2_3_27);
        configuration.setTemplateLoader(getTemplateLoader(templateResource));
        configuration.setObjectWrapper(new DefaultObjectWrapper(Configuration.VERSION_2_3_27));
        configuration.setDefaultEncoding(defaultEncoding);
        this.template = configuration.getTemplate(templateResource.getFilename());
    }

    public void process(Object data) {
        final Environment environment;
        try {
            environment = template.createProcessingEnvironment(data, writer);
            environment.process();
        } catch (TemplateException | IOException e) {
            ExceptionUtils.rethrow(e);
        }

    }

    private TemplateLoader getTemplateLoader(Resource resource) throws IOException {
        if (resource instanceof ClassPathResource classPathResource) {
            return new ClassTemplateLoader(classPathResource.getClassLoader(), "/templates");
        } else if (resource instanceof FileSystemResource fileSystemResource) {
            return new FileTemplateLoader(fileSystemResource.getFile());
        } else {
            throw new IllegalArgumentException("Resource can be FileSystemResource or ClassPathResource");
        }
    }

}

package com.ykb.corebanking.commission.batch.common;

import org.slf4j.MDC;
import org.springframework.core.task.TaskDecorator;

import java.util.Map;

public class MdcTaskDecorator implements TaskDecorator {

    @Override
    public Runnable decorate(Runnable runnable) {
        final Map<String, String> contextMap = MDC.getCopyOfContextMap();
        return () -> {
            try {
                if (contextMap != null) {
                    MDC.setContextMap(contextMap);
                }
                runnable.run();
            } finally {
                MDC.clear();
            }
        };
    }

}

package com.ykb.corebanking.commission.batch.common;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.listener.ItemListenerSupport;
import org.springframework.batch.item.Chunk;

@Slf4j
public class ItemFailureLoggerListener<I, R> extends ItemListenerSupport<I, R> {

    @Override
    public void onReadError(Exception ex) {
        log.error("Encountered error on read", ex);
    }

    @Override
    public void onWriteError(Exception ex, Chunk<? extends R> item) {
        log.error("Encountered error on write", ex);
        if (log.isDebugEnabled()) {
            log.debug("Failed list: {}", item);
        }
    }

}

package com.ykb.corebanking.commission.batch.common;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;


@Slf4j
public class CommonStepExecutionListener implements StepExecutionListener {

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        log.info("Step {} completed at {} with status: {}", stepExecution.getStepName(), stepExecution.getEndTime(), stepExecution.getStatus());
        return stepExecution.getExitStatus();
    }

    @Override
    public void beforeStep(StepExecution stepExecution) {
        log.info("Step {} is started at {}", stepExecution.getStepName(), stepExecution.getStartTime());
    }

}

package com.ykb.corebanking.commission.batch.common;

import com.ykb.corebanking.commission.batch.common.statistic.JobStatistics;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.core.io.ClassPathResource;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;


@Slf4j
public class CommonJobExecutionStatistics {

    public static CommonJobExecutionStatistics getInstance() {
        return new CommonJobExecutionStatistics();
    }

    public void beforeJob(JobExecution jobExecution) {
        log.info("Job {} is started at {}", jobExecution.getJobInstance().getJobName(), jobExecution.getStartTime());
    }

    public void afterJob(JobExecution jobExecution) {
        JobStatistics stats = new JobStatistics(jobExecution);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try (PrintWriter pw = new PrintWriter(bos)) {
            ClassPathResource templateResource = new ClassPathResource("templates/JobStats.ftl");
            TemplateWriter tw = new TemplateWriter(templateResource, pw);
            tw.process(Map.of("stats", stats));
            log.info(new String(bos.toByteArray()));
        } catch (IOException e) {
            log.info("Stats: {}", stats);
        }
        log.info("Job {} is finished at {} with status={}",
                jobExecution.getJobInstance().getJobName(), jobExecution.getEndTime(), jobExecution.getStatus());
    }

}

package com.ykb.corebanking.commission.batch.common;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;


@Slf4j
public class CommonJobExecutionListener implements JobExecutionListener {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        CommonJobExecutionStatistics.getInstance().beforeJob(jobExecution);
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        CommonJobExecutionStatistics.getInstance().afterJob(jobExecution);
    }

}

package com.ykb.corebanking.commission.batch.common.statistic;

import lombok.Getter;
import org.springframework.batch.core.JobExecution;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Getter
public class JobStatistics {

    static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");

    private String jobName;
    private String id;
    private String version;
    private List<JobStatsParameter> parameters;
    private String status;
    private String startTime;
    private String endTime;
    private String exitStatus;
    private String failureExceptions;
    private List<StepStatistics> steps;

    public JobStatistics(JobExecution jobExecution) {
        this.jobName = jobExecution.getJobInstance().getJobName();
        this.id = jobExecution.getJobInstance().getId().toString();
        this.version = jobExecution.getJobInstance().getVersion().toString();
        this.status = jobExecution.getStatus().toString();
        this.startTime = Optional.ofNullable(jobExecution.getStartTime()).orElse(LocalDateTime.MIN).format(DATE_TIME_FORMATTER);
        this.endTime = Optional.ofNullable(jobExecution.getEndTime()).orElse(LocalDateTime.MIN).format(DATE_TIME_FORMATTER);
        this.exitStatus = jobExecution.getExitStatus().toString();
        this.failureExceptions = printStackTrace(jobExecution.getFailureExceptions());
        this.parameters = new ArrayList<>();
        jobExecution.getJobParameters().getParameters().forEach((k, v) -> parameters.add(new JobStatsParameter(k,
                v.getValue().toString())));
        this.steps = new ArrayList<>();
        jobExecution.getStepExecutions().forEach(se -> steps.add(new StepStatistics(se)));
    }

    static String printStackTrace(List<Throwable> exceptions) {
        try (ByteArrayOutputStream os = new ByteArrayOutputStream();
             PrintWriter pw = new PrintWriter(os)) {
            exceptions.forEach(e -> e.printStackTrace(pw));
            return new String(os.toByteArray());
        } catch (IOException e) {
            return "";
        }
    }
}

package com.ykb.corebanking.commission.batch.common.statistic;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class JobStatsParameter {
	private String key;
	private String value;
}
package com.ykb.corebanking.commission.batch.common.statistic;

import lombok.Getter;
import org.springframework.batch.core.StepExecution;

import java.time.LocalDateTime;
import java.util.Optional;

@Getter
public class StepStatistics {
    private String name;
    private String id;
    private String version;
    private String readCount;
    private String writeCount;
    private String commitCount;
    private String rollbackCount;
    private String readSkipCount;
    private String processSkipCount;
    private String writeSkipCount;
    private String startTime;
    private String endTime;
    private String exitStatus;
    private String failureExceptions;

    StepStatistics(StepExecution execution) {
        this.name = execution.getStepName();
        this.id = execution.getId().toString();
        this.version = execution.getVersion().toString();
        this.readCount = String.valueOf(execution.getReadCount());
        this.writeCount = String.valueOf(execution.getWriteCount());
        this.commitCount = String.valueOf(execution.getCommitCount());
        this.rollbackCount = String.valueOf(execution.getRollbackCount());
        this.readSkipCount = String.valueOf(execution.getReadSkipCount());
        this.processSkipCount = String.valueOf(execution.getProcessSkipCount());
        this.writeSkipCount = String.valueOf(execution.getWriteSkipCount());
        this.startTime = Optional.ofNullable(execution.getStartTime()).orElse(LocalDateTime.MIN).format(JobStatistics.DATE_TIME_FORMATTER);
        this.endTime = Optional.ofNullable(execution.getEndTime()).orElse(LocalDateTime.MIN).format(JobStatistics.DATE_TIME_FORMATTER);
        this.exitStatus = execution.getExitStatus().toString();
        this.failureExceptions = JobStatistics.printStackTrace(execution.getFailureExceptions());
    }
}
